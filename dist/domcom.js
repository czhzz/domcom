/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/assets/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/domcom.coffee");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./packages/dc-util/element-pool.js":
/*!******************************************!*\
  !*** ./packages/dc-util/element-pool.js ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar elementPool, nodeCount, nodeCountMax, poolLabelLimit;\n\nelementPool = {};\n\nnodeCount = 0;\n\nnodeCountMax = 500;\n\npoolLabelLimit = {};\n\nexports.createElement = function (namespace, tagName, poolLabel) {\n  var label, node, nodes;\n  if (namespace == null) {\n    namespace = '';\n  }\n  if (tagName == null) {\n    tagName = 'div';\n  }\n  if (poolLabel) {\n    label = tagName + ':' + poolLabel;\n    if (nodes = elementPool[label]) {\n      node = nodes.pop();\n      nodeCount--;\n      return node;\n    }\n  }\n  if (namespace) {\n    return document.createElementNS(namespace || '', tagName);\n  } else {\n    return document.createElement(tagName);\n  }\n};\n\nexports.cacheElement = function (element, poolLabel) {\n  var label, labelMax, nodes;\n  if (nodeCount < nodeCountMax) {\n    label = element.tagName.toLowerCase() + ':' + poolLabel;\n    labelMax = poolLabelLimit[label] || 10;\n    nodes = elementPool[label] || (elementPool[label] = []);\n    if (nodes.length < labelMax) {\n      nodes.push(element);\n      return nodeCount++;\n    }\n  }\n};\n\n//# sourceURL=webpack:///./packages/dc-util/element-pool.js?");

/***/ }),

/***/ "./packages/dc-util/index.js":
/*!***********************************!*\
  !*** ./packages/dc-util/index.js ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\nvar dupStr,\n    globalDcid,\n    hasOwn,\n    isArray,\n    __slice = [].slice;\n\n//export default\nvar _exports = {};\n\n_exports.isArray = isArray = function isArray(item) {\n  return Object.prototype.toString.call(item) === '[object Array]';\n};\n\n_exports.isObject = function (item) {\n  return (typeof item === 'undefined' ? 'undefined' : _typeof(item)) === 'object' && item !== null;\n};\n\n_exports.cloneObject = function (obj) {\n  var key, result;\n  result = {};\n  for (key in obj) {\n    result[key] = obj[key];\n  }\n  return result;\n};\n\n_exports.pairListDict = function () {\n  var i, keyValuePairs, len, result;\n  keyValuePairs = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n  if (keyValuePairs.length === 1) {\n    keyValuePairs = keyValuePairs[0];\n  }\n  len = keyValuePairs.length;\n  i = 0;\n  result = {};\n  while (i < len) {\n    result[keyValuePairs[i]] = keyValuePairs[i + 1];\n    i += 2;\n  }\n  return result;\n};\n\ndupStr = function dupStr(str, n) {\n  var i, s;\n  s = '';\n  i = 0;\n  while (i++ < n) {\n    s += str;\n  }\n  return s;\n};\n\n_exports.newLine = function (str, indent, addNewLine) {\n  if (addNewLine) {\n    return '\\n' + dupStr(' ', indent) + str;\n  } else {\n    return str;\n  }\n};\n\n_exports.funcString = function (fn) {\n  var e, s;\n  if (typeof fn !== 'function') {\n    if (fn == null) {\n      return 'null';\n    }\n    if (fn.getBaseComponent) {\n      return fn.toString();\n    } else {\n      try {\n        return JSON.stringify(fn);\n      } catch (_error) {\n        e = _error;\n        return fn.toString();\n      }\n    }\n  }\n  s = fn.toString();\n  if (fn.invalidate) {\n    return s;\n  }\n  if (s.slice(0, 12) === \"function (){\") {\n    s = s.slice(12, s.length - 1);\n  } else if (s.slice(0, 13) === \"function () {\") {\n    s = s.slice(13, s.length - 1);\n  } else {\n    s = s.slice(9);\n  }\n  s = s.trim();\n  if (s.slice(0, 7) === 'return ') {\n    s = s.slice(7);\n  }\n  if (s[s.length - 1] === ';') {\n    s = s.slice(0, s.length - 1);\n  }\n  return 'fn:' + s;\n};\n\nglobalDcid = 1;\n\n_exports.newDcid = function () {\n  return globalDcid++;\n};\n\n_exports.isEven = function (n) {\n  if (n < 0) {\n    n = -n;\n  }\n  while (n > 0) {\n    n -= 2;\n  }\n  return n === 0;\n};\n\n_exports.matchCurvedString = function (str, i) {\n  var ch, level;\n  if (str[i] !== '(') {\n    return;\n  }\n  level = 0;\n  while (ch = str[++i]) {\n    if (ch === '\\\\') {\n      if (!(ch = str[++i])) {\n        return;\n      }\n    } else if (ch === '(') {\n      level++;\n    } else if (ch === ')') {\n      if (level === 0) {\n        return ++i;\n      } else {\n        level--;\n      }\n    }\n  }\n};\n\n_exports.intersect = function (maps) {\n  var isMember, key, m, m2, result, _i, _len, _ref;\n  result = {};\n  m = maps[0];\n  for (key in m) {\n    isMember = true;\n    _ref = maps.slice(1);\n    for (_i = 0, _len = _ref.length; _i < _len; _i++) {\n      m2 = _ref[_i];\n      if (!m2[key]) {\n        isMember = false;\n        break;\n      }\n    }\n    isMember && (result[key] = m[key]);\n  }\n  return result;\n};\n\n_exports.substractSet = function (whole, unit) {\n  var key;\n  for (key in unit) {\n    delete whole[key];\n  }\n  return whole;\n};\n\n_exports.binarySearch = function (item, items) {\n  var end, index, length, start;\n  length = items.length;\n  if (!length) {\n    return 0;\n  }\n  if (length === 1) {\n    if (items[0] >= item) {\n      return 0;\n    } else {\n      return 1;\n    }\n  }\n  start = 0;\n  end = length - 1;\n  while (1) {\n    index = start + Math.floor((end - start) / 2);\n    if (start === end) {\n      if (items[index] >= item) {\n        return index;\n      } else {\n        return index + 1;\n      }\n    } else if (item === items[index]) {\n      return index;\n    }\n    if (item === items[index + 1]) {\n      return index + 1;\n    } else if (item < items[index]) {\n      end = index;\n    } else if (item > items[index + 1]) {\n      start = index + 1;\n    } else {\n      return index + 1;\n    }\n  }\n};\n\n_exports.binaryInsert = function (item, items) {\n  var end, index, length, start;\n  length = items.length;\n  if (!length) {\n    items[0] = item;\n    return 0;\n  }\n  if (length === 1) {\n    if (items[0] === item) {\n      return 0;\n    } else if (items[0] > item) {\n      items[1] = items[0];\n      items[0] = item;\n      return 0;\n    } else {\n      items[1] = item;\n      return 1;\n    }\n  }\n  start = 0;\n  end = length - 1;\n  while (1) {\n    index = start + Math.floor((end - start) / 2);\n    if (start === end) {\n      if (items[index] === item) {\n        return index;\n      } else if (items[index] > item) {\n        items.splice(index, 0, item);\n        return index;\n      } else {\n        items.splice(index + 1, 0, item);\n        return index + 1;\n      }\n    } else if (item === items[index]) {\n      return index;\n    }\n    if (item === items[index + 1]) {\n      return index + 1;\n    } else if (item < items[index]) {\n      end = index;\n    } else if (item > items[index + 1]) {\n      start = index + 1;\n    } else {\n      items.splice(index + 1, 0, item);\n      return index + 1;\n    }\n  }\n};\n\n_exports.foreach = function (items, callback) {\n  var i, item, key, result, _i, _len;\n  if (!items) {\n    return;\n  }\n  if (isArray(items)) {\n    result = [];\n    for (i = _i = 0, _len = items.length; _i < _len; i = ++_i) {\n      item = items[i];\n      result.push(callback(item, i));\n    }\n  } else {\n    result = {};\n    for (key in items) {\n      item = items[key];\n      result[key] = callback(item, key);\n    }\n  }\n  return result;\n};\n\nhasOwn = Object.hasOwnProperty;\n\n_exports.mixin = function (proto, mix) {\n  var key, value;\n  for (key in mix) {\n    value = mix[key];\n    if (hasOwn.call(proto, key)) {\n      continue;\n    } else {\n      proto[key] = value;\n    }\n  }\n  return proto;\n};\n\n_exports.makeReactMap = function (description) {\n  var field, item, items, pair, reactField, result, _i, _j, _len, _len1, _ref;\n  result = {};\n  items = description.split(/\\s*,\\s*/);\n  for (_i = 0, _len = items.length; _i < _len; _i++) {\n    item = items[_i];\n    pair = item.trim().split(/\\s*:\\s*/);\n    if (pair.length === 1) {\n      result[pair[0]] = '';\n    } else {\n      reactField = pair[1];\n      _ref = pair[0].split(/\\s+/);\n      for (_j = 0, _len1 = _ref.length; _j < _len1; _j++) {\n        field = _ref[_j];\n        result[field] = reactField;\n      }\n    }\n  }\n  return result;\n};\n\nexports.default = _exports;\n\n//# sourceURL=webpack:///./packages/dc-util/index.js?");

/***/ }),

/***/ "./packages/lazy-flow/addon.js":
/*!*************************************!*\
  !*** ./packages/lazy-flow/addon.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar binary, bind, duplex, flow, react, see, unary, _ref;\n\n_ref = __webpack_require__(/*! lazy-flow */ \"./packages/lazy-flow/index.js\"), react = _ref.react, see = _ref.see, bind = _ref.bind, duplex = _ref.duplex, flow = _ref.flow, unary = _ref.unary, binary = _ref.binary;\n\nmodule.exports = flow;\n\nflow.bindings = function (model, name) {\n  var key, result;\n  result = {};\n  for (key in model) {\n    result[key + '$'] = duplex(model, key, name);\n    result[key + '_'] = bind(model, key, name);\n  }\n  return result;\n};\n\nflow.seeAttrs = function (target, from) {\n  var attr, key, value;\n  for (key in from) {\n    value = from[key];\n    attr = target[key];\n    if (typeof attr === 'function') {\n      attr(value);\n    } else {\n      target[key] = see(value);\n    }\n  }\n  return target;\n};\n\nflow.neg = function (x) {\n  return unary(x, function (x) {\n    return -x;\n  });\n};\n\nflow.not = function (x) {\n  return unary(x, function (x) {\n    return !x;\n  });\n};\n\nflow.bitnot = function (x) {\n  return unary(x, function (x) {\n    return ~x;\n  });\n};\n\nflow.reciprocal = function (x) {\n  return unary(x, function (x) {\n    return 1 / x;\n  });\n};\n\nflow.abs = function (x) {\n  return unary(x, Math.abs);\n};\n\nflow.floor = function (x) {\n  return unary(x, Math.floor);\n};\n\nflow.ceil = function (x) {\n  return unary(x, Math.ceil);\n};\n\nflow.round = function (x) {\n  return unary(x, Math.round);\n};\n\nflow.add = function (x, y) {\n  return binary(x, y, function (x, y) {\n    return x + y;\n  });\n};\n\nflow.sub = function (x, y) {\n  return binary(x, y, function (x, y) {\n    return x - y;\n  });\n};\n\nflow.mul = function (x, y) {\n  return binary(x, y, function (x, y) {\n    return x * y;\n  });\n};\n\nflow.div = function (x, y) {\n  return binary(x, y, function (x, y) {\n    return x / y;\n  });\n};\n\nflow.min = function (x, y) {\n  return binary(x, y, function (x, y) {\n    return Math.min(x, y);\n  });\n};\n\nflow.max = function (x, y) {\n  return binary(x, y, function (x, y) {\n    return Math.max(x, y);\n  });\n};\n\nflow.and = function (x, y) {\n  return binary(x, y, function (x, y) {\n    return x && y;\n  });\n};\n\nflow.or = function (x, y) {\n  return binary(x, y, function (x, y) {\n    return x || y;\n  });\n};\n\nflow.funcAttr = function (obj, attr) {\n  return flow(obj, attr, function (value) {\n    var objValue;\n    objValue = obj();\n    if (objValue == null) {\n      return objValue;\n    }\n    if (!arguments.length) {\n      return objValue[attr];\n    } else {\n      return objValue[attr] = value;\n    }\n  });\n};\n\nflow.toggle = function (x) {\n  return x(!x());\n};\n\nflow.if_ = function (test, then_, else_) {\n  if (typeof test !== 'function') {\n    if (test) {\n      return then_;\n    } else {\n      return else_;\n    }\n  } else if (!test.invalidate) {\n    if (typeof then_ === 'function' && typeof else_ === 'function') {\n      return function () {\n        if (test()) {\n          return then_();\n        } else {\n          return else_();\n        }\n      };\n    } else if (then_ === 'function') {\n      return function () {\n        if (test()) {\n          return then_();\n        } else {\n          return else_;\n        }\n      };\n    } else if (else_ === 'function') {\n      return function () {\n        if (test()) {\n          return then_;\n        } else {\n          return else_();\n        }\n      };\n    } else if (test()) {\n      return then_;\n    } else {\n      return else_;\n    }\n  } else {\n    if (typeof then_ === 'function' && typeof else_ === 'function') {\n      if (then_.invalidate && else_.invalidate) {\n        return flow(test, then_, else_, function () {\n          if (test()) {\n            return then_();\n          } else {\n            return else_();\n          }\n        });\n      } else {\n        return function () {\n          if (test()) {\n            return then_();\n          } else {\n            return else_();\n          }\n        };\n      }\n    } else if (typeof then_ === 'function') {\n      if (then_.invalidate) {\n        return flow(test, then_, function () {\n          if (test()) {\n            return then_();\n          } else {\n            return else_;\n          }\n        });\n      } else {\n        return function () {\n          if (test()) {\n            return then_();\n          } else {\n            return else_;\n          }\n        };\n      }\n    } else if (typeof else_ === 'function') {\n      if (else_.invalidate) {\n        return flow(else_, function () {\n          if (test()) {\n            return then_;\n          } else {\n            return else_();\n          }\n        });\n      } else {\n        return function () {\n          if (test()) {\n            return then_;\n          } else {\n            return else_();\n          }\n        };\n      }\n    } else {\n      return flow(test, function () {\n        if (test()) {\n          return then_;\n        } else {\n          return else_;\n        }\n      });\n    }\n  }\n};\n\nflow.thisBind = function (field) {\n  var method;\n  method = react(function () {\n    return this[field];\n  });\n  method.bindComponent = function (component) {\n    var bound;\n    bound = flow.bind(component, field);\n    bound.onInvalidate(function () {\n      method.valid = true;\n      return method.invalidate();\n    });\n    return method;\n  };\n  return method;\n};\n\n//# sourceURL=webpack:///./packages/lazy-flow/addon.js?");

/***/ }),

/***/ "./packages/lazy-flow/index.js":
/*!*************************************!*\
  !*** ./packages/lazy-flow/index.js ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar flow,\n    funcString,\n    lazy,\n    newLine,\n    react,\n    renew,\n    see,\n    _ref,\n    __slice = [].slice;\n\n_ref = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\").default, newLine = _ref.newLine, funcString = _ref.funcString;\n\nreact = function react(method) {\n  if (method.invalidate) {\n    return method;\n  }\n  method.valid = false;\n  method.invalidateCallbacks = [];\n  method.onInvalidate = function (callback) {\n    var invalidateCallbacks;\n    if (typeof callback !== 'function') {\n      throw new Error(\"call back should be a function\");\n    } else {\n      invalidateCallbacks = method.invalidateCallbacks || (method.invalidateCallbacks = []);\n      return invalidateCallbacks.push(callback);\n    }\n  };\n  method.offInvalidate = function (callback) {\n    var index, invalidateCallbacks;\n    invalidateCallbacks = method.invalidateCallbacks;\n    if (invalidateCallbacks && (index = invalidateCallbacks.indexOf(callback)) >= 0) {\n      invalidateCallbacks.splice(index, 1);\n      if (!invalidateCallbacks.length) {\n        method.invalidateCallbacks = null;\n      }\n    }\n    return method;\n  };\n  method.invalidate = function () {\n    var callback, _i, _len, _ref1;\n    if (method.valid && method.invalidateCallbacks) {\n      _ref1 = method.invalidateCallbacks;\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        callback = _ref1[_i];\n        callback();\n      }\n      method.valid = false;\n    }\n    return method;\n  };\n  return method;\n};\n\nrenew = function renew(computation) {\n  var _method;\n  _method = function method() {\n    var value;\n    if (!arguments.length) {\n      value = computation.call(this);\n      _method.valid = true;\n      _method.invalidate();\n      return value;\n    } else {\n      throw new Error('flow.renew is not allowed to accept arguments');\n    }\n  };\n  _method.toString = function () {\n    return \"renew: \" + funcString(computation);\n  };\n  return react(_method);\n};\n\nlazy = function lazy(method) {\n  var oldToString;\n  react(method);\n  method.invalidate = function () {\n    var callback, _i, _len, _ref1;\n    if (method.invalidateCallbacks) {\n      _ref1 = method.invalidateCallbacks;\n      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {\n        callback = _ref1[_i];\n        callback();\n      }\n    }\n    return method;\n  };\n  oldToString = method.toString;\n  method.toString = function () {\n    return \"lazy: \" + oldToString.call(method);\n  };\n  return method;\n};\n\nflow = function flow() {\n  var cacheValue, computation, dep, deps, reactive, _i, _j, _k, _len, _len1;\n  deps = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), computation = arguments[_i++];\n  if (!deps.length) {\n    return lazy(computation);\n  }\n  for (_j = 0, _len = deps.length; _j < _len; _j++) {\n    dep = deps[_j];\n    if (typeof dep === 'function' && !dep.invalidate) {\n      return renew(computation);\n    }\n  }\n  cacheValue = null;\n  reactive = react(function (value) {\n    if (!arguments.length) {\n      if (!reactive.valid) {\n        reactive.valid = true;\n        return cacheValue = computation.call(this);\n      } else {\n        return cacheValue;\n      }\n    } else {\n      if (value === cacheValue) {\n        return value;\n      } else {\n        cacheValue = computation.call(this, value);\n        reactive.invalidate();\n        return cacheValue;\n      }\n    }\n  });\n  for (_k = 0, _len1 = deps.length; _k < _len1; _k++) {\n    dep = deps[_k];\n    if (dep && dep.onInvalidate) {\n      dep.onInvalidate(reactive.invalidate);\n    }\n  }\n  reactive.toString = function () {\n    return \"flow: [\" + function () {\n      var _l, _len2, _results;\n      _results = [];\n      for (_l = 0, _len2 = deps.length; _l < _len2; _l++) {\n        dep = deps[_l];\n        _results.push(dep.toString());\n      }\n      return _results;\n    }().join(',') + \"] --> \" + funcString(computation);\n  };\n  return reactive;\n};\n\nflow.pipe = function () {\n  var computation, dep, deps, reactive, _i, _j, _k, _len, _len1;\n  deps = 2 <= arguments.length ? __slice.call(arguments, 0, _i = arguments.length - 1) : (_i = 0, []), computation = arguments[_i++];\n  for (_j = 0, _len = deps.length; _j < _len; _j++) {\n    dep = deps[_j];\n    if (typeof dep === 'function' && !dep.invalidate) {\n      reactive = react(function () {\n        var args, result, _k, _len1;\n        if (arguments.length) {\n          throw new Error(\"flow.pipe is not allow to have arguments\");\n        }\n        args = [];\n        for (_k = 0, _len1 = deps.length; _k < _len1; _k++) {\n          dep = deps[_k];\n          if (typeof dep === 'function') {\n            args.push(dep());\n          } else {\n            args.push(dep);\n          }\n        }\n        result = computation.apply(this, args);\n        reactive.valid = true;\n        reactive.invalidate();\n        return result;\n      });\n      return reactive;\n    }\n  }\n  reactive = react(function () {\n    var args, _k, _len1;\n    reactive.valid = true;\n    args = [];\n    for (_k = 0, _len1 = deps.length; _k < _len1; _k++) {\n      dep = deps[_k];\n      if (typeof dep === 'function') {\n        args.push(dep());\n      } else {\n        args.push(dep);\n      }\n    }\n    return computation.apply(this, args);\n  });\n  for (_k = 0, _len1 = deps.length; _k < _len1; _k++) {\n    dep = deps[_k];\n    if (dep && dep.onInvalidate) {\n      dep.onInvalidate(reactive.invalidate);\n    }\n  }\n  return reactive;\n};\n\nflow.react = react;\n\nflow.lazy = lazy;\n\nflow.renew = renew;\n\nflow.flow = flow;\n\nflow.see = see = function see(value, transform) {\n  var cacheValue, _method2;\n  cacheValue = value;\n  _method2 = function method(value) {\n    if (!arguments.length) {\n      _method2.valid = true;\n      return cacheValue;\n    } else {\n      value = transform ? transform(value) : value;\n      if (value !== cacheValue) {\n        cacheValue = value;\n        _method2.invalidate();\n      }\n      return value;\n    }\n  };\n  _method2.isDuplex = true;\n  _method2.toString = function () {\n    return \"see: \" + value;\n  };\n  return react(_method2);\n};\n\nflow.seeN = function () {\n  var computation, computations, _i, _len, _results;\n  computations = 1 <= arguments.length ? __slice.call(arguments, 0) : [];\n  _results = [];\n  for (_i = 0, _len = computations.length; _i < _len; _i++) {\n    computation = computations[_i];\n    _results.push(see(computation));\n  }\n  return _results;\n};\n\nif (Object.defineProperty) {\n  flow.bind = function (obj, attr, debugName) {\n    var d, _getter, set, setter;\n    d = Object.getOwnPropertyDescriptor(obj, attr);\n    if (d) {\n      _getter = d.get;\n      set = d.set;\n    }\n    if (!_getter || !_getter.invalidate) {\n      _getter = function getter() {\n        if (arguments.length) {\n          throw new Error('should not set value on flow.bind');\n        }\n        _getter.valid = true;\n        return _getter.cacheValue;\n      };\n      _getter.cacheValue = obj[attr];\n      setter = function setter(value) {\n        if (value !== obj[attr]) {\n          if (set) {\n            set.call(obj, value);\n          }\n          _getter.cacheValue = value;\n          _getter.invalidate();\n          return value;\n        }\n      };\n      react(_getter);\n      _getter.toString = function () {\n        return \"\" + (debugName || 'm') + \"[\" + attr + \"]\";\n      };\n      Object.defineProperty(obj, attr, {\n        get: _getter,\n        set: setter\n      });\n    }\n    return _getter;\n  };\n  flow.duplex = function (obj, attr, debugName) {\n    var d, get, _method3, set;\n    d = Object.getOwnPropertyDescriptor(obj, attr);\n    if (d) {\n      get = d.get, set = d.set;\n    }\n    if (!set || !set.invalidate) {\n      _method3 = function method(value) {\n        if (!arguments.length) {\n          _method3.valid = true;\n          return _method3.cacheValue;\n        }\n        if (value !== obj[attr]) {\n          if (set) {\n            set.call(obj, value);\n          }\n          get && get.invalidate && get.invalidate();\n          _method3.cacheValue = value;\n          _method3.invalidate();\n          return value;\n        }\n      };\n      _method3.cacheValue = obj[attr];\n      react(_method3);\n      _method3.isDuplex = true;\n      _method3.toString = function () {\n        return \"\" + (debugName || 'm') + \"[\" + attr + \"]\";\n      };\n      Object.defineProperty(obj, attr, {\n        get: _method3,\n        set: _method3\n      });\n      return _method3;\n    } else {\n      return set;\n    }\n  };\n} else {\n  flow.bind = function (obj, attr, debugName) {\n    var method, _dcBindMethodMap;\n    _dcBindMethodMap = obj._dcBindMethodMap;\n    if (!_dcBindMethodMap) {\n      _dcBindMethodMap = obj._dcBindMethodMap = {};\n    }\n    if (!obj.dcSet$) {\n      obj.dcSet$ = function (attr, value) {\n        var _dcDuplexMethodMap;\n        if (value !== obj[attr]) {\n          _dcBindMethodMap && _dcBindMethodMap[attr] && _dcBindMethodMap[attr].invalidate();\n          return (_dcDuplexMethodMap = this._dcDuplexMethodMap) && _dcDuplexMethodMap[attr] && _dcDuplexMethodMap[attr].invalidate();\n        }\n      };\n    }\n    method = _dcBindMethodMap[attr];\n    if (!method) {\n      method = _dcBindMethodMap[attr] = function () {\n        method.valid = true;\n        return obj[attr];\n      };\n      method.toString = function () {\n        return \"\" + (debugName || 'm') + \"[\" + attr + \"]\";\n      };\n      react(method);\n    }\n    return method;\n  };\n  flow.duplex = function (obj, attr, debugName) {\n    var method, _dcDuplexMethodMap;\n    _dcDuplexMethodMap = obj._dcDuplexMethodMap;\n    if (!_dcDuplexMethodMap) {\n      _dcDuplexMethodMap = obj._dcDuplexMethodMap = {};\n    }\n    if (!obj.dcSet$) {\n      obj.dcSet$ = function (attr, value) {\n        var _dcBindMethodMap;\n        if (value !== obj[attr]) {\n          (_dcBindMethodMap = this._dcBindMethodMap) && _dcBindMethodMap[attr] && _dcBindMethodMap[attr].invalidate();\n          _dcDuplexMethodMap && _dcDuplexMethodMap[attr] && _dcDuplexMethodMap[attr].invalidate();\n        }\n        return value;\n      };\n    }\n    method = _dcDuplexMethodMap[attr];\n    if (!method) {\n      method = _dcDuplexMethodMap[attr] = function (value) {\n        if (!arguments.length) {\n          method.valid = true;\n          return obj[attr];\n        } else {\n          return obj.dcSet$(attr, value);\n        }\n      };\n      method.isDuplex = true;\n      method.toString = function () {\n        return \"\" + (debugName || 'm') + \"[\" + attr + \"]\";\n      };\n      react(method);\n    }\n    return method;\n  };\n}\n\nflow.unary = function (x, unaryFn) {\n  if (typeof x !== 'function') {\n    return unaryFn(x);\n  } else if (x.invalidate) {\n    return flow(x, function () {\n      return unaryFn(x());\n    });\n  } else {\n    return function () {\n      return unaryFn(x());\n    };\n  }\n};\n\nflow.binary = function (x, y, binaryFn) {\n  if (typeof x === 'function' && typeof y === 'function') {\n    if (x.invalidate && y.invalidate) {\n      return flow(x, y, function () {\n        return binaryFn(x(), y());\n      });\n    } else {\n      return function () {\n        return binaryFn(x(), y());\n      };\n    }\n  } else if (typeof x === 'function') {\n    if (x.invalidate) {\n      return flow(x, function () {\n        return binaryFn(x(), y);\n      });\n    } else {\n      return function () {\n        return binaryFn(x(), y);\n      };\n    }\n  } else if (typeof y === 'function') {\n    if (y.invalidate) {\n      return flow(y, function () {\n        return binaryFn(x, y());\n      });\n    } else {\n      return function () {\n        return binaryFn(x, y());\n      };\n    }\n  } else {\n    return binaryFn(x, y);\n  }\n};\n\nmodule.exports = flow;\nexports.default = flow;\n\n//# sourceURL=webpack:///./packages/lazy-flow/index.js?");

/***/ }),

/***/ "./src/DomNode.coffee":
/*!****************************!*\
  !*** ./src/DomNode.coffee ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _dcUtil = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nvar _domUtil = __webpack_require__(/*! ./dom-util */ \"./src/dom-util.coffee\");\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nvar DomNode, processProp;\n\nprocessProp = function processProp(props, cache, prop, value) {\n  var j, len, p;\n\n  if (value == null) {\n    if (typeof prop === 'string') {\n      return props[prop];\n    } else {\n      for (value = j = 0, len = prop.length; j < len; value = ++j) {\n        p = prop[value];\n\n        if (cacheProps[p] == null || value !== cacheProps[p]) {\n          cacheProps[p] = props[p] = value;\n        }\n      }\n    }\n  } else {\n    if (cacheProps[prop] == null || value !== cacheProps[prop]) {\n      return cacheProps[prop] = this.node[prop] = value;\n    }\n  }\n};\n\nvar _default = module.exports = DomNode =\n/*#__PURE__*/\nfunction () {\n  function DomNode(node1) {\n    _classCallCheck(this, DomNode);\n\n    var n;\n    this.node = node1;\n\n    if (node instanceof Node) {\n      this.cacheProps = {};\n      this.cacheStyle = {};\n    } else {\n      this.cacheProps = function () {\n        var j, len, ref, results;\n        ref = this.node;\n        results = [];\n\n        for (j = 0, len = ref.length; j < len; j++) {\n          n = ref[j];\n          results.push({});\n        }\n\n        return results;\n      }.call(this);\n\n      this.cacheStyle = function () {\n        var j, len, ref, results;\n        ref = this.node;\n        results = [];\n\n        for (j = 0, len = ref.length; j < len; j++) {\n          n = ref[j];\n          results.push({});\n        }\n\n        return results;\n      }.call(this);\n    }\n  }\n\n  _createClass(DomNode, [{\n    key: \"prop\",\n    value: function prop(_prop, value) {\n      var i, j, len, n, node;\n      node = this.node;\n\n      if (!arguments.length) {\n        return node;\n      } else if (node instanceof Node) {\n        return processProp(node, this.cacheProps, _prop, value);\n      } else {\n        for (i = j = 0, len = node.length; j < len; i = ++j) {\n          n = node[i];\n          processProp(n, this.cacheProps[i], _prop, value);\n        }\n      }\n    }\n  }, {\n    key: \"css\",\n    value: function css(prop, value) {\n      var i, j, len, n, node;\n      node = this.node;\n\n      if (!arguments.length) {\n        return ndoe.style;\n      } else if (node instanceof Node) {\n        return processProp(node.style, this.cacheStyle, prop, value);\n      } else {\n        for (i = j = 0, len = node.length; j < len; i = ++j) {\n          n = node[i];\n          processProp(n.style, this.cacheStyle[i], prop, value);\n        }\n      }\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(eventNames, handler) {\n      var j, k, len, len1, n, name, node, ref;\n      node = this.node;\n      ref = eventNames.split(/\\s+/);\n\n      for (j = 0, len = ref.length; j < len; j++) {\n        name = ref[j];\n\n        if (name.slice(0, 2) === 'on') {\n          name = name.slice(2);\n        }\n\n        if (node instanceof Node) {\n          (0, _domUtil.addEventListener)(node, name, handler);\n        } else {\n          for (k = 0, len1 = node.length; k < len1; k++) {\n            n = node[k];\n            (0, _domUtil.addEventListener)(n, name, handler);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind(eventNames, handler) {\n      var j, k, len, len1, n, name, node, ref;\n      node = this.node;\n      ref = eventNames.split(/\\s+/);\n\n      for (j = 0, len = ref.length; j < len; j++) {\n        name = ref[j];\n\n        if (name.slice(0, 2) === 'on') {\n          name = name.slice(2);\n        }\n\n        if (node instanceof Node) {\n          (0, _domUtil.removeEventListener)(node, name, handler);\n        } else {\n          for (k = 0, len1 = node.length; k < len1; k++) {\n            n = node[k];\n            (0, _domUtil.removeEventListener)(n, name, handler);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var addNewLine = arguments.length > 1 ? arguments[1] : undefined;\n      return (0, _dcUtil.newLine)('', indent, addNewLine) + '<DomNode>' + (0, _dcUtil.newLine)(this.node.toString(), indent + 2, true) + (0, _dcUtil.newLine)('</DomNode>', indent, true);\n    }\n  }]);\n\n  return DomNode;\n}();\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/DomNode.coffee?");

/***/ }),

/***/ "./src/Emitter.coffee":
/*!****************************!*\
  !*** ./src/Emitter.coffee ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\nModel, View, Component等很多类的基类\n管理注册／注销回调函数(on/once/off/offall)和事件发布(emit)\n*/\nvar Emitter;\n\nvar _default = module.exports = Emitter =\n/*#__PURE__*/\nfunction () {\n  function Emitter() {\n    _classCallCheck(this, Emitter);\n  }\n  /*注册事件\n    comp.on({name:callbacks...})\n    comp.on(name, callback, before = false)\n    comp.on(name, callbacks, before = false)\n  */\n\n\n  _createClass(Emitter, [{\n    key: \"on\",\n    value: function on(event, callback) {\n      var callbacks, eventName, i, len, listeners, ref;\n\n      if (!arguments.length) {\n        dc.error('missing arguments for Component.on(event, callback)');\n      }\n\n      if (arguments.length === 1) {\n        if (!event || _typeof(event) !== 'object') {\n          dc.error('wrong arguments for Component.on(event, callback)');\n        } else {\n          for (eventName in event) {\n            callback = event[eventName];\n            this.on(eventName, callback);\n          }\n        }\n      } else {\n        if (!callback) {\n          dc.error('Component.on: callback is undefined for event: ' + event);\n        }\n\n        if (!(listeners = this.listeners)) {\n          this.listeners = listeners = {};\n        }\n\n        ref = event.split(/\\s*,\\s*|\\s+/);\n\n        for (i = 0, len = ref.length; i < len; i++) {\n          event = ref[i];\n\n          if (callbacks = listeners[event]) {\n            if (callbacks.indexOf(callback) < 0) {\n              callbacks.push(callback);\n            }\n          } else {\n            listeners[event] = [callback];\n          }\n        }\n      }\n\n      return this;\n    }\n    /*注册事件\n     * comp.off(name, callback)\n     * 注销部件上指定name的指定回调函数\n      * comp.off(name)\n     * 注销部件上指定name的所有回调函数\n      * comp.off() \n    #注销部件上的所有事件的所有回调函数\n      */\n\n  }, {\n    key: \"off\",\n    value: function off(event, callback) {\n      var callbacks, i, index, j, len, len1, listeners, ref, ref1;\n\n      if (!arguments.length) {\n        this.listeners = {};\n      } else if (arguments.length === 1) {\n        listeners = this.listeners;\n        ref = event.split(/\\s*,\\s*|\\s+/);\n\n        for (i = 0, len = ref.length; i < len; i++) {\n          event = ref[i];\n          listeners[event] = null;\n        }\n      } else {\n        listeners = this.listeners;\n        ref1 = event.split(/\\s*,\\s*|\\s+/);\n\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          event = ref1[j];\n          callbacks = listeners[event];\n\n          if (callbacks && (index = callbacks.indexOf(callback)) >= 0) {\n            callbacks.splice(index, 1);\n\n            if (!callbacks.length) {\n              listeners[event] = null;\n            }\n          }\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"once\",\n    value: function once(event, callback) {\n      var _onceCallback;\n\n      if (!callback) {\n        dc.error('Component.once: callback is undefined for event: ' + event);\n      }\n\n      _onceCallback = function onceCallback() {\n        this.off(event, _onceCallback);\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return callback.apply(this, args);\n      };\n\n      return this.on(event, _onceCallback);\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(event) {\n      var callback, callbacks, i, len, method;\n\n      if (!this.destroyed) {\n        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n\n        if (this.listeners && (callbacks = this.listeners[event])) {\n          // need to be copied, because onceCallback will be removed from this.listeners[event]\n          callbacks = callbacks.slice();\n\n          for (i = 0, len = callbacks.length; i < len; i++) {\n            callback = callbacks[i];\n            callback.apply(this, args);\n          }\n        } else {\n          if (method = this['on' + event]) {\n            method.apply(this, args);\n          }\n        }\n      }\n\n      return this;\n    }\n  }]);\n\n  return Emitter;\n}();\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/Emitter.coffee?");

/***/ }),

/***/ "./src/backend/Angular.coffee":
/*!************************************!*\
  !*** ./src/backend/Angular.coffee ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _Backend2 = _interopRequireDefault(__webpack_require__(/*! ./Backend */ \"./src/backend/Backend.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Angular;\n\nvar _default = Angular =\n/*#__PURE__*/\nfunction (_Backend) {\n  _inherits(Angular, _Backend);\n\n  function Angular() {\n    _classCallCheck(this, Angular);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Angular).apply(this, arguments));\n  }\n\n  return Angular;\n}(_Backend2.default);\n\nexports.default = _default;\nmodule.exports = Angular;\n\n//# sourceURL=webpack:///./src/backend/Angular.coffee?");

/***/ }),

/***/ "./src/backend/Backend.coffee":
/*!************************************!*\
  !*** ./src/backend/Backend.coffee ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\n  不同的后端使用不同的技术来实现Dom的管理（初步计划支持原生 、jquery、React，Vue，Angular几种后端，首先重点考虑一两种）\n\n*/\nvar Backend;\n\nvar _default = Backend =\n/*#__PURE__*/\nfunction () {\n  function Backend() {\n    _classCallCheck(this, Backend);\n  } //    if this instanceof Backend\n  //      dc.error(new Error('Backend is an abstract Base Class;\\n should not create the instance of Backend directly,\\n use its Derived classes instead'))\n  // 子类构造器应该增加tags属性用于创建标签部件\n  //如backend.div(...)\n  //创建基于部件类的部件，该部件将使用此后端管理Dom相关行为\n  //假如dcreact是用于React的Backend子类实例\n  //如 dcreact.by(SomeReactComponentClass)\n  //创建一个使用SomeReactComponentClass的dc部件\n\n\n  _createClass(Backend, [{\n    key: \"by\",\n    value: function by(ComponentClass) {\n      var comp;\n      comp = new Component();\n      comp.ComponentClass = ComponentClass;\n      comp.backend = this;\n      return comp;\n    } //渲染部件DOM\n    //大概不会作为公开API，计划被部件调用\n    //应该被实际的后端子类重定义\n\n  }, {\n    key: \"render\",\n    value: function render(component) {} //挂载部件DOM\n    //大概不会作为公开API，计划被部件调用\n\n  }, {\n    key: \"mount\",\n    value: function mount(component, element) {} //卸载部件DOM\n    //大概不会作为公开API，计划被部件调用\n\n  }, {\n    key: \"unmount\",\n    value: function unmount(component) {} //创建部件DOM\n    //大概不会作为公开API，计划被部件调用\n\n  }, {\n    key: \"create\",\n    value: function create(component) {}\n  }]);\n\n  return Backend;\n}();\n\nexports.default = _default;\nmodule.exports = Backend;\n\n//# sourceURL=webpack:///./src/backend/Backend.coffee?");

/***/ }),

/***/ "./src/backend/Html.coffee":
/*!*********************************!*\
  !*** ./src/backend/Html.coffee ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _Backend2 = _interopRequireDefault(__webpack_require__(/*! ./Backend */ \"./src/backend/Backend.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Html;\n\nvar _default = Html =\n/*#__PURE__*/\nfunction (_Backend) {\n  _inherits(Html, _Backend);\n\n  function Html() {\n    _classCallCheck(this, Html);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Html).apply(this, arguments));\n  }\n\n  return Html;\n}(_Backend2.default);\n\nexports.default = _default;\nmodule.exports = Html;\n\n//# sourceURL=webpack:///./src/backend/Html.coffee?");

/***/ }),

/***/ "./src/backend/React.coffee":
/*!**********************************!*\
  !*** ./src/backend/React.coffee ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _Backend2 = _interopRequireDefault(__webpack_require__(/*! ./Backend */ \"./src/backend/Backend.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar React;\n\nvar _default = React = function () {\n  var React =\n  /*#__PURE__*/\n  function (_Backend) {\n    _inherits(React, _Backend);\n\n    function React() {\n      _classCallCheck(this, React);\n\n      return _possibleConstructorReturn(this, _getPrototypeOf(React).call(this));\n    }\n\n    return React;\n  }(_Backend2.default);\n\n  ;\n  React.prototype.name = 'React';\n  return React;\n}.call(void 0); // 增加用于引用React Tag标签的属性，以创建React基本标签部件\n// 如dcreact.div\n\n\nexports.default = _default;\nmodule.exports = React;\n\n//# sourceURL=webpack:///./src/backend/React.coffee?");

/***/ }),

/***/ "./src/backend/Vue.coffee":
/*!********************************!*\
  !*** ./src/backend/Vue.coffee ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _Backend2 = _interopRequireDefault(__webpack_require__(/*! ./Backend */ \"./src/backend/Backend.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Vue;\n\nvar _default = Vue =\n/*#__PURE__*/\nfunction (_Backend) {\n  _inherits(Vue, _Backend);\n\n  function Vue() {\n    _classCallCheck(this, Vue);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Vue).apply(this, arguments));\n  }\n\n  return Vue;\n}(_Backend2.default);\n\nexports.default = _default;\nmodule.exports = Vue;\n\n//# sourceURL=webpack:///./src/backend/Vue.coffee?");

/***/ }),

/***/ "./src/backend/index.coffee":
/*!**********************************!*\
  !*** ./src/backend/index.coffee ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _Angular = _interopRequireDefault(__webpack_require__(/*! ./Angular */ \"./src/backend/Angular.coffee\"));\n\nvar _Html = _interopRequireDefault(__webpack_require__(/*! ./Html */ \"./src/backend/Html.coffee\"));\n\nvar _React = _interopRequireDefault(__webpack_require__(/*! ./React */ \"./src/backend/React.coffee\"));\n\nvar _Vue = _interopRequireDefault(__webpack_require__(/*! ./Vue */ \"./src/backend/Vue.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _exports;\n\nmodule.exports = _exports = {\n  Angular: _Angular.default,\n  Html: _Html.default,\n  React: _React.default,\n  Vue: _Vue.default,\n  ng: function ng() {\n    return new _Angular.default();\n  },\n  html: function html() {\n    return new _Html.default();\n  },\n  react: function react() {\n    return new _React.default();\n  },\n  vue: function vue() {\n    return new _Vue.default();\n  }\n};\nvar _default = _exports;\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/backend/index.coffee?");

/***/ }),

/***/ "./src/component/BaseComponent.coffee":
/*!********************************************!*\
  !*** ./src/component/BaseComponent.coffee ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _Component2 = _interopRequireDefault(__webpack_require__(/*! ./Component */ \"./src/component/Component.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nvar BaseComponent;\n\nvar _default = BaseComponent =\n/*#__PURE__*/\nfunction (_Component) {\n  _inherits(BaseComponent, _Component);\n\n  function BaseComponent() {\n    var _this;\n\n    _classCallCheck(this, BaseComponent);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(BaseComponent).call(this));\n    _this.isBaseComponent = true;\n    _this.removing = false; // the line below is moved from ListMixin\n    // because the removing Component of TranComponent will be added to TranComponent.content\n\n    _this.baseComponent = _assertThisInitialized(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(BaseComponent, [{\n    key: \"refreshDom\",\n    value: function refreshDom(oldBaseComponent) {\n      this.renderDom();\n      this.attachParent();\n      return this;\n    }\n  }, {\n    key: \"renderDom\",\n    value: function renderDom(oldBaseComponent) {\n      this.emit('willRenderDom');\n\n      if (oldBaseComponent && oldBaseComponent !== this) {\n        oldBaseComponent.markRemovingDom();\n      }\n\n      this.renderBaseComponent(oldBaseComponent);\n      this.emit('didRenderDom');\n      return this;\n    }\n  }, {\n    key: \"renderBaseComponent\",\n    value: function renderBaseComponent(oldBaseComponent) {\n      if (oldBaseComponent && oldBaseComponent !== this) {\n        this.attachValid = false;\n\n        if (this.holder) {\n          this.holder.invalidateAttach(this);\n        }\n      }\n\n      if (!this.node) {\n        this.createDom();\n\n        if (this.holder) {\n          this.holder.invalidateAttach(this);\n        }\n      } else {\n        if (!this.valid) {\n          this.updateDom();\n        }\n      }\n    }\n  }, {\n    key: \"invalidate\",\n    value: function invalidate() {\n      if (this.valid) {\n        this.valid = false;\n        return this.holder && this.holder.invalidateContent(this);\n      } else {\n        return this;\n      }\n    }\n  }, {\n    key: \"resetAttach\",\n    value: function resetAttach() {\n      return this.attachValid = false;\n    }\n  }, {\n    key: \"attachChildren\",\n    value: function attachChildren() {}\n  }, {\n    key: \"markRemovingDom\",\n    value: function markRemovingDom() {\n      this.removing = true;\n      this.holder = null;\n      dc.removingChildren[this.dcid] = this;\n      return this;\n    }\n  }, {\n    key: \"markRemoving\",\n    value: function markRemoving() {\n      this.removing = true;\n    }\n  }, {\n    key: \"clearRemoving\",\n    value: function clearRemoving() {\n      return this.removing = this.removed = false;\n    }\n  }, {\n    key: \"removeDom\",\n    value: function removeDom() {\n      var child, i, len, ref;\n\n      if (this.removing) {\n        this.emit('willDetach');\n\n        if (this.isList) {\n          this.removing = false;\n          this.removed = true;\n          this.node.parentNode = null;\n          this.childParentNode = null;\n          ref = this.children;\n\n          for (i = 0, len = ref.length; i < len; i++) {\n            child = ref[i];\n            child.removeDom();\n          }\n        } else {\n          this.removeNode();\n        }\n\n        this.emit('didDetach');\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeNode\",\n    value: function removeNode() {\n      var node;\n      this.removing = false;\n      this.removed = true;\n\n      if (node = this.node) {\n        node.parentNode && node.parentNode.removeChild(node);\n      }\n    }\n  }, {\n    key: \"attachParent\",\n    value: function attachParent() {\n      var nextNode, node, parentNode;\n      node = this.node;\n      parentNode = this.parentNode;\n      nextNode = this.nextNode;\n      this.removing = false;\n\n      if (parentNode && (parentNode !== node.parentNode || nextNode !== node.nextSibling)) {\n        this.emit('willAttach');\n        parentNode.insertBefore(node, nextNode);\n        this.emit('didAttach');\n      }\n\n      return node;\n    }\n  }]);\n\n  return BaseComponent;\n}(_Component2.default);\n\nexports.default = _default;\nmodule.exports = BaseComponent;\n\n//# sourceURL=webpack:///./src/component/BaseComponent.coffee?");

/***/ }),

/***/ "./src/component/Case.coffee":
/*!***********************************!*\
  !*** ./src/component/Case.coffee ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _toComponent = _interopRequireDefault(__webpack_require__(/*! ./toComponent */ \"./src/component/toComponent.coffee\"));\n\nvar _TestComponent2 = _interopRequireDefault(__webpack_require__(/*! ./TestComponent */ \"./src/component/TestComponent.coffee\"));\n\nvar _dcUtil = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nvar _lazyFlow = __webpack_require__(/*! lazy-flow */ \"./packages/lazy-flow/index.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Case;\n\nvar _default = module.exports = Case =\n/*#__PURE__*/\nfunction (_TestComponent) {\n  _inherits(Case, _TestComponent);\n\n  function Case(test, map1, else_) {\n    var _this;\n\n    var forceCase = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n\n    _classCallCheck(this, Case);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Case).call(this, test));\n    _this.map = map1;\n    (0, _dcUtil.foreach)(map, function (value, index) {\n      return map[index] = (0, _toComponent.default)(value);\n    });\n    _this.else_ = (0, _toComponent.default)(else_);\n    return _possibleConstructorReturn(_this);\n  }\n\n  _createClass(Case, [{\n    key: \"getContentComponent\",\n    value: function getContentComponent() {\n      return this.map[this.test] || this.else_;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var cloneMap;\n      cloneMap = (0, _dcUtil.foreach)(this.map, function (value) {\n        return value.clone();\n      });\n      return new Case(this.test, cloneMap, this.else_.clone()).copyEventListeners(this);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var addNewLine = arguments.length > 1 ? arguments[1] : undefined;\n      var s;\n      s = (0, _dcUtil.newLine)('', indent, addNewLine) + '<Case ' + (0, _dcUtil.funcString)(this.test) + '>';\n      (0, _dcUtil.foreach)(this.map, function (value, index) {\n        return s += (0, _dcUtil.newLine)(index + ': ' + value.toString(indent + 2, false), indent + 2, true);\n      });\n      return s += this.else_.toString(indent + 2, true) + (0, _dcUtil.newLine)('</Case>', indent, true);\n    }\n  }]);\n\n  return Case;\n}(_TestComponent2.default);\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/component/Case.coffee?");

/***/ }),

/***/ "./src/component/Cdata.coffee":
/*!************************************!*\
  !*** ./src/component/Cdata.coffee ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _BaseComponent = _interopRequireDefault(__webpack_require__(/*! ./BaseComponent */ \"./src/component/BaseComponent.coffee\"));\n\nvar _Text2 = _interopRequireDefault(__webpack_require__(/*! ./Text */ \"./src/component/Text.coffee\"));\n\nvar _dcUtil = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nvar _domUtil = __webpack_require__(/*! ../dom-util */ \"./src/dom-util.coffee\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Cdata;\n\nvar _default = module.exports = Cdata =\n/*#__PURE__*/\nfunction (_Text) {\n  _inherits(Cdata, _Text);\n\n  function Cdata(text) {\n    _classCallCheck(this, Cdata);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Cdata).call(this, text));\n  }\n  /*\n  this operation is not supported in html document\n  */\n\n\n  _createClass(Cdata, [{\n    key: \"createDom\",\n    value: function createDom() {\n      this.node = document.createCDATASection((0, _domUtil.domValue)(this.text, this));\n      return this.node;\n    }\n  }, {\n    key: \"updateDom\",\n    value: function updateDom() {\n      this.text && (this.node.data = (0, _domUtil.domValue)(this.text, this));\n      return this.node;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n      var addNewLine = arguments.length > 1 ? arguments[1] : undefined;\n      return (0, _dcUtil.newLine)(\"<CDATA \".concat((0, _dcUtil.funcString)(this.text), \"/>\"), indent, addNewLine);\n    }\n  }]);\n\n  return Cdata;\n}(_Text2.default);\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/component/Cdata.coffee?");

/***/ }),

/***/ "./src/component/Comment.coffee":
/*!**************************************!*\
  !*** ./src/component/Comment.coffee ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _BaseComponent = _interopRequireDefault(__webpack_require__(/*! ./BaseComponent */ \"./src/component/BaseComponent.coffee\"));\n\nvar _Text2 = _interopRequireDefault(__webpack_require__(/*! ./Text */ \"./src/component/Text.coffee\"));\n\nvar _dcUtil = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nvar _domUtil = __webpack_require__(/*! ../dom-util */ \"./src/dom-util.coffee\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Comment;\n\nvar _default = module.exports = Comment =\n/*#__PURE__*/\nfunction (_Text) {\n  _inherits(Comment, _Text);\n\n  function Comment(text) {\n    _classCallCheck(this, Comment);\n\n    return _possibleConstructorReturn(this, _getPrototypeOf(Comment).call(this, text));\n  }\n\n  _createClass(Comment, [{\n    key: \"createDom\",\n    value: function createDom() {\n      var node, text;\n      this.valid = true;\n      text = (0, _domUtil.domValue)(this.text, this);\n      node = document.createComment(text);\n      this.node = this.firstNode = node;\n      this.cacheText = text;\n      return this.node;\n    }\n  }, {\n    key: \"updateDom\",\n    value: function updateDom() {\n      var node, parentNode, text;\n      this.valid = true;\n      text = (0, _domUtil.domValue)(this.text, this);\n\n      if (text !== this.cacheText) {\n        parentNode = node.parentNode;\n\n        if (parentNode) {\n          parentNode.removeChild(node);\n        }\n\n        node = document.createComment(text);\n        this.node = this.firstNode = node;\n        this.cacheText = text;\n      }\n\n      return this.node;\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n      var addNewLine = arguments.length > 1 ? arguments[1] : undefined;\n      return (0, _dcUtil.newLine)(\"<Comment \".concat((0, _dcUtil.funcString)(this.text), \"/>\"), indent, addNewLine);\n    }\n  }]);\n\n  return Comment;\n}(_Text2.default);\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/component/Comment.coffee?");

/***/ }),

/***/ "./src/component/Component.coffee":
/*!****************************************!*\
  !*** ./src/component/Component.coffee ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _Emitter2 = _interopRequireDefault(__webpack_require__(/*! ../Emitter */ \"./src/Emitter.coffee\"));\n\nvar _domUtil = __webpack_require__(/*! ../dom-util */ \"./src/dom-util.coffee\");\n\nvar _dcUtil = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nvar _lazyFlow = __webpack_require__(/*! lazy-flow */ \"./packages/lazy-flow/index.js\");\n\nvar _isComponent = _interopRequireDefault(__webpack_require__(/*! ./isComponent */ \"./src/component/isComponent.coffee\"));\n\nvar _dc = _interopRequireDefault(__webpack_require__(/*! ../dc */ \"./src/dc.coffee\"));\n\nvar _dcEvent = _interopRequireDefault(__webpack_require__(/*! ../dc-event */ \"./src/dc-event.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Component, flowBind;\nflowBind = _lazyFlow.flow.bind;\n\n/*\n  所有部件的基类\n\n*/\nvar _default = module.exports = Component =\n/*#__PURE__*/\nfunction (_Emitter) {\n  _inherits(Component, _Emitter);\n\n  function Component(template, model) {\n    var _this;\n\n    _classCallCheck(this, Component);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Component).call(this));\n    _this.view = null;\n    _this.model = null;\n    _this.backend = null;\n    return _this;\n  }\n  /*\n  设置部件模版 this.view\n  */\n\n\n  _createClass(Component, [{\n    key: \"with\",\n    value: function _with(view) {\n      this.view = view;\n      return this;\n    }\n    /*\n    设置部件数据模型 this.model\n    */\n\n  }, {\n    key: \"data\",\n    value: function data(model1) {\n      this.model = model1;\n      return this;\n    }\n    /*\n    设置部件后端 this.backend\n    */\n\n  }, {\n    key: \"use\",\n    value: function use(backend) {\n      this.backend = backend;\n      return this;\n    }\n    /*\n    ## 渲染部件\n    * 基本步骤\n    * 计算即时数据映像\n    * 计算vdom\n    * 更新dom\n     */\n\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.data = this.compute();\n      this.vdom = this.refresh();\n      this.update();\n      return this;\n    }\n    /*\n    根据部件数据模型this.model计算即时数据映像this.data\n    */\n\n  }, {\n    key: \"compute\",\n    value: function compute() {}\n  }, {\n    key: \"_prepareMount\",\n    value: function _prepareMount(mountNode, beforeNode) {\n      if (mountNode && mountNode.component) {\n        mountNode = mountNode.component;\n      } else if (beforeNode && beforeNode.component) {\n        console.log(mountNode);\n        console.log(beforeNode);\n        throw new Error('error while mounting: mountNode is not a component, but beforeNode is a component');\n      }\n\n      if ((0, _isComponent.default)(mountNode)) {\n        if (!beforeNode) {\n          if (!mountNode.children) {\n            console.log(mountNode);\n            throw new Error('error while mounting: mountNode is a component, but is not a Tag or List component');\n          }\n\n          return mountNode.pushChild(this);\n        } else {\n          if (!(0, _isComponent.default)(beforeNode)) {\n            beforeNode = beforeNode.component;\n\n            if (!beforeNode) {\n              console.log(beforeNode);\n              throw new Error('error while mounting: can not mount beforeNode');\n            }\n          }\n\n          if (beforeNode.holder !== mountNode || !mountNode.children) {\n            console.log(mountNode);\n            console.log(beforeNode);\n            throw new Error('both mountNode and beforeNode is component, but mountNode is not the parent of beforeNode');\n          }\n\n          return mountNode.insertChildBefore(this, beforeNode);\n        }\n      } else {\n        this.parentNode = (0, _domUtil.normalizeDomElement)(mountNode) || this.parentNode || document.body;\n        this.nextNode = beforeNode || this.nextNode;\n        this.setHolder(_dc.default);\n        this.clearRemoving();\n        return _dc.default.rootComponentMap[this.dcid] = this;\n      }\n    }\n    /* if mountNode is given, it should not be the node of any Component\n    only use beforeNode if mountNode is given\n    */\n\n  }, {\n    key: \"mount\",\n    value: function mount(mountNode, beforeNode, forceRender) {\n      this.emit('willMount');\n\n      this._prepareMount(mountNode, beforeNode);\n\n      this.render(forceRender);\n      return this.emit('didMount');\n    }\n  }, {\n    key: \"unmount\",\n    value: function unmount(forceRender) {\n      this.emit('willUnmount');\n      this.remove(); //this.removeNode()\n\n      _dc.default.clean();\n\n      return this.emit('didUnmount');\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var firstNode, holder;\n      holder = this.holder;\n\n      if (!holder || holder === _dc.default) {\n        delete _dc.default.rootComponentMap[this.dcid];\n        firstNode = this.firstNode;\n\n        if (firstNode && firstNode.parentNode) {\n          this.markRemovingDom();\n        }\n      } else if (holder && holder.children) {\n        holder.removeChild(this);\n      } else if (holder) {\n        _dc.default.error('Should not remove the content of TranComponent');\n      }\n\n      return this;\n    }\n    /* 注册部件的事件侦听回掉\n     ## 调用示例\n    comp.on(name, callback, before = false)\n    comp.on(name, callbacks, before = false)\n    comp.on({name: callback, ...}, before = false)\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(event, callback) {\n      return callback;\n    }\n    /* 取消注册部件的事件侦听回掉\n     ## 调用示例\n    comp.off(name, callback)\n    comp.off(name)\n    comp.off(names)\n    comp.off()\n    comp.on({name: callback, ...})\n     */\n\n  }, {\n    key: \"on\",\n    value: function on(event, callback) {}\n    /* 发送部件事件\n    */\n\n  }, {\n    key: \"emit\",\n    value: function emit(name) {}\n  }, {\n    key: \"replace\",\n    value: function replace(oldComponent, forceRender) {\n      var holder;\n\n      if (!this.destroyed && this !== oldComponent && !oldComponent.removing && !oldComponent.removed) {\n        holder = oldComponent.holder;\n\n        if (holder && holder !== _dc.default) {\n          if (holder.isTransformComponent) {\n            _dc.default.error('Should not replace the content of TranComponent');\n          } else {\n            // holder is List or Tag\n            holder.replaceChild(oldComponent, this);\n          } //          holder.render(forceRender)\n          //          oldComponent.removeDom()\n\n        } else if (holder === _dc.default) {\n          this.parentNode = oldComponent.parentNode;\n          this.nextNode = oldComponent.nextNode;\n          oldComponent.markRemovingDom();\n          this.setHolder(holder);\n          this.invalidate();\n          _dc.default.rootComponentMap[this.dcid] = this;\n          delete _dc.default.rootComponentMap[oldComponent.dcid];\n        }\n      }\n\n      return this;\n    }\n    /*\n    component.renderWhen components, events, options\n    component.renderWhen setInterval, interval, options\n    component.renderWhen setTimeout, interval, options\n    */\n\n  }, {\n    key: \"renderWhen\",\n    value: function renderWhen(cause, events, options) {\n      options = options || {};\n      options.target = [this];\n\n      _dc.default.renderWhen(cause, events, options);\n\n      return this;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.emit('willDestroy');\n      this.executeDestroy();\n      return this.emit('didDestroy');\n    }\n  }, {\n    key: \"executeDestroy\",\n    value: function executeDestroy() {\n      this.unmount(true);\n      this.destroyed = true;\n      this.listeners = null;\n\n      if (this.node) {\n        this.node.component = null;\n        this.node = null;\n      }\n\n      this.BaseComponent = null;\n      return this.parentNode = null;\n    }\n  }, {\n    key: \"getPrevComponent\",\n    value: function getPrevComponent() {\n      var children, holder;\n\n      if (!(holder = this.holder)) {\n        return null;\n      } else if (children = holder.children) {\n        return children[children.indexOf(this) - 1];\n      }\n    }\n  }, {\n    key: \"getNextComponent\",\n    value: function getNextComponent() {\n      var children, holder;\n\n      if (!(holder = this.holder)) {\n        return null;\n      } else if (children = holder.children) {\n        return children[children.indexOf(this) - 1];\n      }\n    }\n  }, {\n    key: \"setNextNode\",\n    value: function setNextNode(nextNode) {\n      this.nextNode = nextNode;\n    }\n  }, {\n    key: \"setHolder\",\n    value: function setHolder(holder) {\n      if (this.holder && this.holder !== holder) {\n        this.holder.invalidateAttach(this);\n      }\n\n      this.holder = holder;\n      return this;\n    }\n  }, {\n    key: \"isOffspringOf\",\n    value: function isOffspringOf(ancestor) {\n      var holder;\n      holder = this.holder;\n\n      while (holder) {\n        if (holder === ancestor) {\n          return true;\n        }\n\n        holder = holder.holder;\n      }\n\n      return false;\n    }\n  }, {\n    key: \"inFamilyOf\",\n    value: function inFamilyOf(ancestor) {\n      return this === ancestor || this.isOffspringOf(ancestor);\n    }\n  }, {\n    key: \"setReactive\",\n    value: function setReactive() {\n      var invalidateThis, me, reactField, reactive, ref, srcField;\n\n      if (this.reactMap) {\n        me = this;\n\n        invalidateThis = function invalidateThis() {\n          return me.invalidate();\n        };\n\n        ref = this.reactMap;\n\n        for (srcField in ref) {\n          reactField = ref[srcField];\n          reactive = flowBind(this, srcField);\n\n          if (typeof reactField === 'string') {\n            reactive.onInvalidate(function () {\n              var reaction;\n\n              if (reaction = me[reactField]) {\n                return reaction.invalidate();\n              }\n            });\n          } else {\n            reactive.onInvalidate(invalidateThis);\n          }\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"copyEventListeners\",\n    value: function copyEventListeners(srcComponent) {\n      var event, myListeners, srcListeners;\n      myListeners = this.listeners;\n      srcListeners = srcComponent.listeners;\n\n      for (event in srcListeners) {\n        srcListeners[event] && (myListeners[event] = srcListeners[event].splice());\n      }\n\n      return this;\n    }\n  }]);\n\n  return Component;\n}(_Emitter2.default);\n\nexports.default = _default;\nObject.assign(Component.prototype, _dcEvent.default);\n\n//# sourceURL=webpack:///./src/component/Component.coffee?");

/***/ }),

/***/ "./src/component/Defer.coffee":
/*!************************************!*\
  !*** ./src/component/Defer.coffee ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _toComponent = _interopRequireDefault(__webpack_require__(/*! ./toComponent */ \"./src/component/toComponent.coffee\"));\n\nvar _TranComponent2 = _interopRequireDefault(__webpack_require__(/*! ./TranComponent */ \"./src/component/TranComponent.coffee\"));\n\nvar _dcUtil = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nvar _lazyFlow = __webpack_require__(/*! lazy-flow */ \"./packages/lazy-flow/index.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nvar Defer, FULFILL, INIT, REJECT;\nINIT = 0;\nFULFILL = 1;\nREJECT = 2;\n\nvar _default = module.exports = Defer =\n/*#__PURE__*/\nfunction (_TranComponent) {\n  _inherits(Defer, _TranComponent);\n\n  function Defer(promise1, fulfill, reject, init) {\n    var _this;\n\n    _classCallCheck(this, Defer);\n\n    var family, treject;\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Defer).call(this));\n    _this.promise = promise1;\n\n    _this.fulfill = fulfill || function (result) {\n      return result;\n    };\n\n    treject = reject || function (error) {\n      return error;\n    };\n\n    _this.init = init && init(promise, _assertThisInitialized(_assertThisInitialized(_this))) || new Nothing();\n    _this.family = family = (0, _dcUtil.intersect)([fullfill.family, reject.family, init.family]);\n    family[_this.dcid] = true;\n    _this.promiseState = INIT;\n    promise.then(function (value) {\n      this.promiseResult = value;\n      this.promiseState = FULFILL;\n      return this.invalidateTransform();\n    }).catch(function (error) {\n      this.promiseResult = error;\n      this.promiseState = REJECT;\n      return this.invalidateTransform();\n    });\n    return _possibleConstructorReturn(_this, _assertThisInitialized(_assertThisInitialized(_this)));\n  }\n\n  _createClass(Defer, [{\n    key: \"getContentComponent\",\n    value: function getContentComponent() {\n      var state;\n\n      if ((state = this.promiseState) === INIT) {\n        return init;\n      } else if (state === FULFILL) {\n        return (0, _toComponent.default)(this.fulfill(this.promiseResult, this.promise, this));\n      } else {\n        return (0, _toComponent.default)(this.reject(this.promiseResult, this.promise, this));\n      }\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Defer(this.promise, this.fulfill, this.reject, this.init.clone).copyEventListeners(this);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var addNewLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      return (0, _dcUtil.newLine)('', indent, addNewLine) + '<Defer ' + this.promise + '>' + (0, _dcUtil.newLine)('', indent, addNewLine) + (0, _dcUtil.funcString)(this.fulfill) + (0, _dcUtil.newLine)('', indent, addNewLine) + (0, _dcUtil.funcString)(this.reject) + this.init.toString(indent + 2, true) + (0, _dcUtil.newLine)('</Defer>', indent, true);\n    }\n  }]);\n\n  return Defer;\n}(_TranComponent2.default);\n\nexports.default = _default;\nObject.assign(Defer, {\n  INIT: INIT,\n  FULFILL: FULFILL,\n  REJECT: REJECT\n});\n\n//# sourceURL=webpack:///./src/component/Defer.coffee?");

/***/ }),

/***/ "./src/component/Func.coffee":
/*!***********************************!*\
  !*** ./src/component/Func.coffee ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _toComponent = _interopRequireDefault(__webpack_require__(/*! ./toComponent */ \"./src/component/toComponent.coffee\"));\n\nvar _TranComponent2 = _interopRequireDefault(__webpack_require__(/*! ./TranComponent */ \"./src/component/TranComponent.coffee\"));\n\nvar _dcUtil = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nvar _lazyFlow = __webpack_require__(/*! lazy-flow */ \"./packages/lazy-flow/index.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nvar Func;\n\nvar _default = module.exports = Func =\n/*#__PURE__*/\nfunction (_TranComponent) {\n  _inherits(Func, _TranComponent);\n\n  function Func(func) {\n    var _this;\n\n    _classCallCheck(this, Func);\n\n    var me;\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Func).call(this));\n\n    if (!func.invalidate) {\n      _this.func = (0, _lazyFlow.renew)(func);\n    } else {\n      _this.func = func;\n    }\n\n    me = _assertThisInitialized(_assertThisInitialized(_this));\n\n    _this.func.onInvalidate(function () {\n      return me.invalidateTransform();\n    });\n\n    _assertThisInitialized(_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  _createClass(Func, [{\n    key: \"getContentComponent\",\n    value: function getContentComponent() {\n      return (0, _toComponent.default)(this.func());\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Func(this.func).copyEventListeners(this);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n      var addNewLine = arguments.length > 1 ? arguments[1] : undefined;\n      return (0, _dcUtil.newLine)(\"<Func \".concat((0, _dcUtil.funcString)(this.func), \"/>\"), indent, addNewLine);\n    }\n  }]);\n\n  return Func;\n}(_TranComponent2.default);\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/component/Func.coffee?");

/***/ }),

/***/ "./src/component/Html.coffee":
/*!***********************************!*\
  !*** ./src/component/Html.coffee ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _Tag2 = _interopRequireDefault(__webpack_require__(/*! ./Tag */ \"./src/component/Tag.coffee\"));\n\nvar _dcUtil = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nvar _domUtil = __webpack_require__(/*! ../dom-util */ \"./src/dom-util.coffee\");\n\nvar _attrs = __webpack_require__(/*! ../property/attrs */ \"./src/property/attrs.coffee\");\n\nvar _elementPool = __webpack_require__(/*! dc-util/element-pool */ \"./packages/dc-util/element-pool.js\");\n\nvar _ListMixin = _interopRequireDefault(__webpack_require__(/*! ./ListMixin */ \"./src/component/ListMixin.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Html, HtmlMixin, method;\n\n// !!! Warning:\n// By default, Html does not escape to safe the html.\n// So it's UNSAFE to use Html class without a transform function!!!\n// It's the responsibility of user program to keep it in safe!\n// Maybe a npm package like escape-html will help.\n// this is Html Component, which take some text as innerHTML\n// for <html> ... </html>, please use tagHtml instead\nvar _default = module.exports = Html =\n/*#__PURE__*/\nfunction (_Tag) {\n  _inherits(Html, _Tag);\n\n  function Html(attrs, text, transform) {\n    var _this;\n\n    _classCallCheck(this, Html);\n\n    var tagName;\n\n    if (typeof attrs === 'string' || typeof attrs === 'function') {\n      transform = text;\n      text = attrs;\n      attrs = {};\n    } else {\n      attrs = attrs || {};\n    }\n\n    if (attrs.tagName) {\n      tagName = attrs.tagName;\n      delete attrs.tagName;\n    } else {\n      tagName = 'div';\n    }\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Html).call(this, tagName, attrs, []));\n\n    _this.initHtmlComponent(text, transform);\n\n    return _this;\n  }\n\n  _createClass(Html, [{\n    key: \"toString\",\n    value: function toString() {\n      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n      var addNewLine = arguments.length > 1 ? arguments[1] : undefined;\n      return (0, _dcUtil.newLine)(\"<Html \".concat((0, _dcUtil.funcString)(this._text), \"/>\"), indent, addNewLine);\n    }\n  }]);\n\n  return Html;\n}(_Tag2.default);\n\nexports.default = _default;\nHtml.HtmlMixin = HtmlMixin = {\n  setText: _attrs.setText,\n  initHtmlComponent: function initHtmlComponent(text, transform) {\n    var get, me, set;\n    this.transform = transform;\n    this.setText(text);\n\n    if (Object.defineProperty) {\n      me = this;\n\n      get = function get() {\n        return me._text;\n      };\n\n      set = function set(text) {\n        me.setText(text);\n        return text;\n      };\n\n      return Object.defineProperty(this, 'text', {\n        get: get,\n        set: set\n      });\n    }\n  },\n  // initListMixin is called by the constructor of Tag class\n  // so put an empty definition here\n  initListMixin: function initListMixin() {},\n  attachChildren: function attachChildren() {},\n  createDom: function createDom() {\n    var node, text;\n    this.valid = true;\n    this.node = this.firstNode = node = (0, _elementPool.createElement)(this.namespace, this.tagName, this.poolLabel);\n    node.component = this;\n    this.updateProperties();\n    text = (0, _domUtil.domValue)(this._text, this);\n\n    if (this.transform) {\n      text = this.transform(text);\n    }\n\n    this.cacheText = node.innerHTML = text;\n    return this;\n  },\n  updateDom: function updateDom() {\n    var namespace, node, text;\n    this.valid = true;\n    text = (0, _domUtil.domValue)(this._text, this);\n\n    if (this.transform) {\n      text = this.transform(text);\n    }\n\n    node = this.node;\n    namespace = this.namespace || \"http://www.w3.org/1999/xhtml\";\n\n    if (this.tagName !== this.node.tagName.toLowerCase() || namespace !== this.node.namespaceURI) {\n      node = this.node;\n      node.parentNode && node.parentNode.removeChild(node);\n      this.node = this.firstNode = node = (0, _elementPool.createElement)(this.namespace, this.tagName, this.poolLabel);\n      node.component = this;\n      node.innerHTML = this.cacheText = text;\n      this.holder.invalidateAttach(this);\n      this.restoreCacheProperties();\n    } else if (text !== this.cacheText) {\n      if (node.childNodes.length >= 2) {\n        if (node.parentNode) {\n          this.removeNode();\n        }\n\n        this.node = this.firstNode = node = node.cloneNode(false);\n        node.component = this;\n      }\n\n      node.innerHTML = text;\n      this.cacheText = text;\n    } // this should be done after this.node is processed\n    // because may be cloneNode\n\n\n    this.updateProperties();\n    return this;\n  }\n};\n\nfor (method in _ListMixin.default) {\n  (function (method) {\n    return Html.prototype[method] = function () {\n      return dc.error(\"Html component has no children components, do not call ListMixin method(\".concat(method, \") on it\"));\n    };\n  })(method);\n}\n\nObject.assign(Html.prototype, HtmlMixin);\n\n//# sourceURL=webpack:///./src/component/Html.coffee?");

/***/ }),

/***/ "./src/component/If.coffee":
/*!*********************************!*\
  !*** ./src/component/If.coffee ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _toComponent = _interopRequireDefault(__webpack_require__(/*! ./toComponent */ \"./src/component/toComponent.coffee\"));\n\nvar _TestComponent2 = _interopRequireDefault(__webpack_require__(/*! ./TestComponent */ \"./src/component/TestComponent.coffee\"));\n\nvar _dcUtil = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nvar _lazyFlow = __webpack_require__(/*! lazy-flow */ \"./packages/lazy-flow/index.js\");\n\nvar _mergeIf = _interopRequireDefault(__webpack_require__(/*! ../mergeIf */ \"./src/mergeIf.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nvar If, ObjectDefineProperty;\nObjectDefineProperty = Object.defineProperty;\n\nvar _default = module.exports = If =\n/*#__PURE__*/\nfunction (_TestComponent) {\n  _inherits(If, _TestComponent);\n\n  function If(test, then_, else_, merge, recursive) {\n    var _this;\n\n    var forceIf = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : false;\n\n    _classCallCheck(this, If);\n\n    if (then_ === else_) {\n      return _possibleConstructorReturn(_this, (0, _toComponent.default)(then_));\n    }\n\n    then_ = (0, _toComponent.default)(then_);\n    else_ = (0, _toComponent.default)(else_);\n\n    if (!forceIf) {\n      if (typeof test !== 'function') {\n        if (test) {\n          return _possibleConstructorReturn(_this, then_);\n        } else {\n          return _possibleConstructorReturn(_this, else_);\n        }\n      } else if (merge) {\n        return _possibleConstructorReturn(_this, (0, _mergeIf.default)(test, then_, else_, recursive));\n      }\n    }\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(If).call(this, test));\n    _this.then_ = then_;\n    _this.else_ = else_;\n    return _possibleConstructorReturn(_this, _assertThisInitialized(_assertThisInitialized(_this)));\n  }\n\n  _createClass(If, [{\n    key: \"getContentComponent\",\n    value: function getContentComponent() {\n      if (this.test) {\n        return this.then_;\n      } else {\n        return this.else_;\n      }\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new If(this.test, this.then_.clone(), this.else_.clone()).copyEventListeners(this);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var addNewLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      return (0, _dcUtil.newLine)('', indent, addNewLine) + '<if ' + (0, _dcUtil.funcString)(this.test) + '>' + this.then_.toString(indent + 2, true) + this.else_.toString(indent + 2, true) + (0, _dcUtil.newLine)('</if>', indent, true);\n    }\n  }]);\n\n  return If;\n}(_TestComponent2.default);\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/component/If.coffee?");

/***/ }),

/***/ "./src/component/List.coffee":
/*!***********************************!*\
  !*** ./src/component/List.coffee ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _BaseComponent2 = _interopRequireDefault(__webpack_require__(/*! ./BaseComponent */ \"./src/component/BaseComponent.coffee\"));\n\nvar _dcUtil = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nvar _toComponentArray = _interopRequireDefault(__webpack_require__(/*! ./toComponentArray */ \"./src/component/toComponentArray.coffee\"));\n\nvar _ListMixin = _interopRequireDefault(__webpack_require__(/*! ./ListMixin */ \"./src/component/ListMixin.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar List, ListMixinAttachChildren;\n\nvar _default = module.exports = List =\n/*#__PURE__*/\nfunction (_BaseComponent) {\n  _inherits(List, _BaseComponent);\n\n  function List(children) {\n    var _this;\n\n    _classCallCheck(this, List);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(List).call(this));\n    _this.children = (0, _toComponentArray.default)(children);\n\n    _this.initListMixin();\n\n    _this.isList = true;\n    return _possibleConstructorReturn(_this);\n  }\n\n  _createClass(List, [{\n    key: \"refreshDom\",\n    value: function refreshDom(oldBaseComponent) {\n      this.renderDom();\n      this.attachChildren();\n      return this;\n    }\n  }, {\n    key: \"createDom\",\n    value: function createDom() {\n      this.valid = true;\n      this.node = this.childNodes;\n      this.createChildrenDom();\n      this.firstNode = this.childrenFirstNode;\n      return this.node;\n    }\n  }, {\n    key: \"updateDom\",\n    value: function updateDom() {\n      this.valid = true;\n      this.updateChildrenDom();\n      this.firstNode = this.childrenFirstNode;\n      return this.node;\n    }\n  }, {\n    key: \"markRemovingDom\",\n    value: function markRemovingDom() {\n      var child, i, len, ref;\n      this.removing = true;\n      this.holder = null;\n      ref = this.children;\n\n      for (i = 0, len = ref.length; i < len; i++) {\n        child = ref[i];\n        child.markRemoving();\n      }\n\n      dc.removingChildren[this.dcid] = this;\n      return this;\n    }\n  }, {\n    key: \"markRemoving\",\n    value: function markRemoving() {\n      var child, i, len, ref;\n      this.removing = true;\n      ref = this.children;\n\n      for (i = 0, len = ref.length; i < len; i++) {\n        child = ref[i];\n        child.markRemoving();\n      }\n    }\n  }, {\n    key: \"clearRemoving\",\n    value: function clearRemoving() {\n      var child, i, len, ref;\n      this.removing = this.removed = false;\n      ref = this.children;\n\n      for (i = 0, len = ref.length; i < len; i++) {\n        child = ref[i];\n        child.clearRemoving();\n      }\n    } // removeDom: ->\n    // this method is coded in BaseComponent.removeDom\n    // the case for Component.isList is considered there\n\n  }, {\n    key: \"removeNode\",\n    value: function removeNode() {\n      var child, i, len, ref;\n      this.removing = false;\n      this.removed = true;\n      this.node.parentNode = null;\n      this.childParentNode = null;\n      ref = this.children;\n\n      for (i = 0, len = ref.length; i < len; i++) {\n        child = ref[i];\n        child.baseComponent.removeNode();\n      }\n    }\n  }, {\n    key: \"invalidateAttach\",\n    value: function invalidateAttach(child) {\n      var index;\n      index = this.children.indexOf(child);\n      (0, _dcUtil.binaryInsert)(index, this.attachingIndexes);\n\n      if (this.attachValid) {\n        this.attachValid = false;\n\n        if (this.holder) {\n          this.holder.invalidateAttach(this);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"resetAttach\",\n    value: function resetAttach() {\n      var child, i, len, ref;\n      this.attachValid = false;\n      ref = this.children;\n\n      for (i = 0, len = ref.length; i < len; i++) {\n        child = ref[i];\n        child.resetAttach();\n      }\n    }\n  }, {\n    key: \"attachParent\",\n    value: function attachParent() {\n      var nextNode, node, parentNode;\n      node = this.node;\n      parentNode = this.parentNode;\n      nextNode = this.nextNode;\n      this.removing = false;\n\n      if (parentNode && (parentNode !== node.parentNode || nextNode !== node.nextSibling)) {\n        this.emit('willAttach');\n        ListMixinAttachChildren.call(this);\n        return this.emit('didAttach');\n      }\n    }\n  }, {\n    key: \"setNextNode\",\n    value: function setNextNode(nextNode) {\n      var child, children, index;\n      this.nextNode = nextNode;\n      this.childrenNextNode = nextNode;\n      children = this.children;\n      index = children.length - 1;\n\n      while (child = children[index]) {\n        child.setNextNode(nextNode);\n\n        if (!child.firstNode) {\n          index--;\n        } else {\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"clone\",\n    value: function clone(options) {\n      var result;\n      result = new List(this.cloneChildren(options));\n      result.constructor = this.constructor;\n      return result.copyEventListeners(this);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var addNewLine = arguments.length > 1 ? arguments[1] : undefined;\n      var child, i, len, ref, s;\n\n      if (!this.children.length) {\n        return (0, _dcUtil.newLine)(\"<List/>\", indent, addNewLine);\n      } else {\n        s = (0, _dcUtil.newLine)(\"<List>\", indent, addNewLine);\n        ref = this.children;\n\n        for (i = 0, len = ref.length; i < len; i++) {\n          child = ref[i];\n          s += child.toString(indent + 2, true);\n        }\n\n        return s += (0, _dcUtil.newLine)('</List>', indent, true);\n      }\n    }\n  }]);\n\n  return List;\n}(_BaseComponent2.default);\n\nexports.default = _default;\n(0, _dcUtil.mixin)(List.prototype, _ListMixin.default);\nListMixinAttachChildren = _ListMixin.default.attachChildren;\n\n//# sourceURL=webpack:///./src/component/List.coffee?");

/***/ }),

/***/ "./src/component/ListMixin.coffee":
/*!****************************************!*\
  !*** ./src/component/ListMixin.coffee ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _dcUtil = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nvar _isComponent = _interopRequireDefault(__webpack_require__(/*! ./isComponent */ \"./src/component/isComponent.coffee\"));\n\nvar _toComponent = _interopRequireDefault(__webpack_require__(/*! ./toComponent */ \"./src/component/toComponent.coffee\"));\n\nvar _Nothing = _interopRequireDefault(__webpack_require__(/*! ./Nothing */ \"./src/component/Nothing.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// if not using binarySearch, it's too expensive to update new index after inserting or removing child\nvar addIndexes, extendChildFamily, insertIndex, removeIndex, setNextNodes;\n\nvar _require = __webpack_require__(/*! ../dom-util */ \"./src/dom-util.coffee\");\n\nextendChildFamily = _require.extendChildFamily;\n\ninsertIndex = function insertIndex(index, indexes) {\n  var i;\n  i = (0, _dcUtil.binarySearch)(index, indexes);\n  indexes.splice(i, 0, index);\n  addIndexes(indexes, 1, i + 1);\n};\n\nremoveIndex = function removeIndex(index, indexes) {\n  var i;\n  i = (0, _dcUtil.binarySearch)(index, indexes);\n\n  if (indexes[i] === index) {\n    indexes.splice(i, 1);\n  }\n\n  addIndexes(indexes, -1, i);\n};\n\naddIndexes = function addIndexes(indexes, value, start) {\n  var i, length; // value can be 1 or -1\n\n  length = indexes.length;\n  i = start;\n\n  while (i < length) {\n    indexes[i] += value;\n\n    if (indexes[i] < 0) {\n      throw 'negative index in ListMixin component';\n    }\n\n    i++;\n  }\n};\n\nsetNextNodes = function setNextNodes(children, nextNode, last, first) {\n  var child, i;\n  i = last;\n\n  while (i >= first) {\n    child = children[i];\n\n    if (child.nextNode !== nextNode) {\n      child.nextNode = nextNode;\n\n      if (!child.firstNode) {\n        i--;\n        nextNode = child.firstNode;\n      } else {\n        break;\n      }\n    } else {\n      break;\n    }\n  }\n};\n\nvar _default = module.exports = {\n  initListMixin: function initListMixin() {\n    var child, family, i, j, len, ref;\n    this.updatingIndexes = [];\n    this.attachingIndexes = [];\n    this.childNodes = [];\n    this.family = family = {};\n    family[this.dcid] = true;\n    this.children = this.children || [];\n    ref = this.children;\n\n    for (i = j = 0, len = ref.length; j < len; i = ++j) {\n      child = ref[i];\n      child.setHolder(this);\n      child.clearRemoving();\n      extendChildFamily(family, child);\n    }\n  },\n  cloneChildrenFrom: function cloneChildrenFrom(component, options) {\n    var child, children, i, j, len, ref;\n    children = [];\n    ref = component.children;\n\n    for (i = j = 0, len = ref.length; j < len; i = ++j) {\n      child = ref[i];\n      children.push(this.cloneChild(child, i, options, component));\n    }\n\n    return this.setChildren(0, children);\n  },\n  cloneChild: function cloneChild(child, index, options, srcComponent) {\n    return child.clone(options);\n  },\n  createChildrenDom: function createChildrenDom() {\n    var child, firstNode, firstNodeIndex, index, j, len, node, ref;\n    node = this.childNodes;\n    firstNode = null;\n    this.updatingIndexes = [];\n    ref = this.children;\n\n    for (index = j = 0, len = ref.length; j < len; index = ++j) {\n      child = ref[index];\n      child.setHolder(this);\n      child.renderDom(child.BaseComponent);\n      node.push(child.node);\n\n      if (!firstNode && child.firstNode) {\n        firstNode = child.firstNode;\n        firstNodeIndex = index;\n      }\n    }\n\n    this.childrenFirstNode = firstNode;\n    this.firstNodeIndex = firstNodeIndex;\n  },\n  updateChildrenDom: function updateChildrenDom() {\n    var child, children, index, j, len, node, updatingIndexes;\n    updatingIndexes = this.updatingIndexes;\n    this.updatingIndexes = [];\n    node = this.childNodes;\n    children = this.children;\n\n    for (j = 0, len = updatingIndexes.length; j < len; j++) {\n      index = updatingIndexes[j];\n      child = children[index];\n      child.setHolder(this);\n      child.renderDom(child.BaseComponent);\n      index = children.indexOf(child);\n      node[index] = child.node;\n      this.updateChildrenFirstNode(child, index);\n    }\n  },\n  insertChildBefore: function insertChildBefore(child, refChild) {\n    return this.insertChild(refChild, child);\n  },\n  insertChildAfter: function insertChildAfter(child, refChild) {\n    var children;\n    children = this.children;\n\n    if ((0, _isComponent.default)(refChild)) {\n      refChild = children.indexOf(refChild);\n\n      if (refChild < 0) {\n        refChild = 0;\n      }\n    }\n\n    return this.insertChild(refChild + 1, child);\n  },\n  pushChild: function pushChild() {\n    var i, length, thisChildren;\n    thisChildren = this.children;\n\n    for (var _len = arguments.length, children = new Array(_len), _key = 0; _key < _len; _key++) {\n      children[_key] = arguments[_key];\n    }\n\n    length = children.length;\n    i = 0;\n\n    while (i < length) {\n      this.insertChild(thisChildren.length, children[i]);\n      i++;\n    }\n\n    return this;\n  },\n  insertChild: function insertChild(refChild, child) {\n    var children, index, length;\n    children = this.children;\n    length = children.length;\n\n    if (refChild == null) {\n      index = length;\n    } else if ((0, _isComponent.default)(refChild)) {\n      index = children.indexOf(refChild);\n\n      if (index < 0) {\n        index = length;\n      }\n    } else if (refChild > length) {\n      index = length;\n      refChild = null;\n    } else if (refChild < 0) {\n      index = 0;\n      refChild = null;\n    } else {\n      index = refChild;\n      refChild = children[index];\n    }\n\n    this.emit('onInsertChild', index, refChild, child);\n    child = (0, _toComponent.default)(child);\n    return this._insertChild(index, child);\n  },\n  _insertChild: function _insertChild(index, child) {\n    var children;\n    children = this.children;\n    children.splice(index, 0, child);\n    child.setHolder(this);\n    child.clearRemoving();\n    child.parentNode = this.childParentNode;\n\n    if (index === children.length - 1) {\n      child.setNextNode(this.childrenNextNode);\n    } else {\n      child.setNextNode(children[index + 1].firstNode || children[index + 1].nextNode);\n    }\n\n    if (this.node) {\n      this.childNodes.splice(index, 0, child.node);\n\n      if (!child.node || !child.valid) {\n        this.valid = false;\n        insertIndex(index, this.updatingIndexes);\n\n        if (this.holder) {\n          this.holder.invalidateContent(this);\n        }\n      }\n\n      if (this.holder) {\n        this.holder.invalidateAttach(this);\n      }\n\n      this.attachValid = false;\n      insertIndex(index, this.attachingIndexes);\n\n      if (child.firstNode && (!this.childrenFirstNode || index <= this.firstNodeIndex)) {\n        this.childrenFirstNode = child.firstNode;\n        this.firstNodeIndex = index;\n      }\n    }\n\n    return this;\n  },\n  unshiftChild: function unshiftChild() {\n    var i;\n\n    for (var _len2 = arguments.length, children = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      children[_key2] = arguments[_key2];\n    }\n\n    i = children.length - 1;\n\n    while (i >= 0) {\n      this.insertChild(0, children[i]);\n      i--;\n    }\n\n    return this;\n  },\n  shiftChild: function shiftChild() {\n    return this.removeChild(0);\n  },\n  popChild: function popChild() {\n    var length;\n    length = this.children.length;\n\n    if (length) {\n      return this.removeChild(length - 1);\n    } else {\n      return this;\n    }\n  },\n  removeChild: function removeChild(child) {\n    var childFirstNode, children, index;\n\n    if (child == null) {\n      dc.error('child to be removed is undefined');\n    }\n\n    children = this.children;\n\n    if ((0, _isComponent.default)(child)) {\n      index = children.indexOf(child);\n\n      if (index < 0) {\n        dc.error('child to be removed is not in the children');\n      }\n    } else if (child >= children.length || child < 0) {\n      dc.error('child(' + child + ') to be removed is out of range');\n    } else {\n      index = child;\n      child = children[index];\n    }\n\n    removeIndex(index, this.updatingIndexes);\n    child = children[index];\n\n    if (this.node) {\n      this.childNodes.splice(index, 1);\n\n      if (childFirstNode = child.firstNode) {\n        if (this.firstNodeIndex === index) {\n          this.setFirstNodeWithFollowing(index);\n        }\n\n        this.linkNextNode(index, childFirstNode, child.nextNode);\n      }\n\n      child.markRemovingDom();\n      removeIndex(index, this.attachingIndexes);\n    }\n\n    (0, _dcUtil.substractSet)(this.family, child.family);\n    children.splice(index, 1);\n\n    if (child.holder === this) {\n      child.holder = null;\n    }\n\n    return child;\n  },\n  removeRange: function removeRange(start, stop) {\n    var children, index, last;\n    children = this.children;\n    last = children.length - 1;\n    index = start;\n\n    if (index < 0) {\n      index = 0;\n    }\n\n    if (stop > last) {\n      stop = last;\n    }\n\n    while (index <= stop) {\n      this.removeChild(index);\n      index++;\n    }\n\n    return this;\n  },\n  setFirstNodeWithFollowing: function setFirstNodeWithFollowing(index) {\n    var children, firstNode, length;\n    children = this.children;\n    length = children.length;\n    index++;\n\n    while (index < length) {\n      if (firstNode = children[index].firstNode) {\n        this.childrenFirstNode = firstNode;\n        this.firstNodeIndex = index;\n        return;\n      }\n\n      index++;\n    }\n\n    this.childrenFirstNode = null;\n  },\n  replaceChild: function replaceChild(oldChild, newChild) {\n    var children, index;\n    children = this.children;\n\n    if ((0, _isComponent.default)(oldChild)) {\n      index = children.indexOf(oldChild);\n\n      if (index < 0) {\n        dc.error('oldChild to be replaced is not in the children');\n      }\n    } else {\n      if (oldChild >= children.length || oldChild < 0) {\n        dc.error('oldChild(' + oldChild + ') to be replaced is out of range');\n      }\n\n      index = oldChild;\n      oldChild = children[index];\n    }\n\n    this.emit('onReplaceChild', index, oldChild, newChild);\n    newChild = (0, _toComponent.default)(newChild);\n    return this._replaceChild(index, oldChild, newChild);\n  },\n  _replaceChild: function _replaceChild(index, oldChild, newChild) {\n    var children;\n    children = this.children;\n\n    if (oldChild === newChild) {\n      return this;\n    }\n\n    children[index] = newChild;\n\n    if (oldChild.holder === this) {\n      oldChild.holder = null;\n    }\n\n    oldChild.markRemovingDom();\n    newChild.setHolder(this);\n    newChild.clearRemoving();\n    newChild.parentNode = oldChild.parentNode;\n    newChild.nextNode = oldChild.nextNode;\n    (0, _dcUtil.substractSet)(this.family, oldChild.family);\n    extendChildFamily(this.family, newChild);\n\n    if (this.node) {\n      this.childNodes[index] = newChild.node;\n\n      if (!newChild.node || !newChild.valid) {\n        this.invalidateContent(newChild);\n      }\n\n      this.invalidateAttach(newChild);\n      dc.removingChildren[oldChild.dcid] = oldChild;\n      this.updateChildrenFirstNode(newChild, index);\n    }\n\n    return this;\n  },\n  updateChildrenFirstNode: function updateChildrenFirstNode(newChild, index) {\n    if (this.childrenFirstNode) {\n      if (newChild.firstNode) {\n        if (index <= this.firstNodeIndex) {\n          this.childrenFirstNode = newChild.firstNode;\n          this.firstNodeIndex = index;\n        }\n      } else if (index === this.firstNodeIndex) {\n        this.setFirstNodeWithFollowing(index);\n      }\n    } else {\n      if (newChild.firstNode) {\n        this.childrenFirstNode = newChild.firstNode;\n        this.firstNodeIndex = index;\n      }\n    }\n  },\n  setChildren: function setChildren(startIndex, newChildren) {\n    var child, children, i, j, len, n, oldChildrenLength;\n    children = this.children;\n    oldChildrenLength = children.length;\n    n = oldChildrenLength;\n\n    while (n < startIndex) {\n      this.pushChild(new _Nothing.default());\n      n++;\n    }\n\n    for (i = j = 0, len = newChildren.length; j < len; i = ++j) {\n      child = newChildren[i];\n\n      if (startIndex + i < oldChildrenLength) {\n        this.replaceChild(startIndex + i, newChildren[i]);\n      } else {\n        this.pushChild(newChildren[i]);\n      }\n    }\n\n    return this;\n  },\n  setLength: function setLength(newLength) {\n    var children, last;\n    children = this.children;\n\n    if (newLength >= children.length) {\n      return this;\n    } else {\n      last = children.length - 1;\n\n      while (last >= newLength) {\n        this.removeChild(last);\n        last--;\n      }\n\n      return this;\n    }\n  },\n  invalidateContent: function invalidateContent(child) {\n    var index;\n    index = this.children.indexOf(child);\n    (0, _dcUtil.binaryInsert)(index, this.updatingIndexes);\n\n    if (this.valid) {\n      this.valid = false;\n      this.holder && this.holder.invalidateContent(this);\n    }\n\n    return this;\n  },\n  invalidateChildren: function invalidateChildren() {\n    var child, j, len, ref;\n    this.invalidate();\n    ref = this.children;\n\n    for (j = 0, len = ref.length; j < len; j++) {\n      child = ref[j];\n      child.valid = false;\n    }\n\n    return this;\n  },\n  attachChildren: function attachChildren() {\n    var childParentNode;\n    childParentNode = this.childParentNode;\n\n    if (!childParentNode || !this.attachValid || !this.childNodes.parentNode) {\n      this.attachValid = true;\n\n      if (this.isList) {\n        this.childParentNode = this.parentNode;\n        this.childrenNextNode = this.nextNode;\n      } else if (!childParentNode) {\n        this.childParentNode = this.node;\n        this.childrenNextNode = null;\n      }\n\n      if (this.childParentNode !== this.childNodes.parentNode) {\n        this.attachAllChildren();\n      } else {\n        this.attachInvalidChildren();\n      }\n    }\n  },\n  attachAllChildren: function attachAllChildren() {\n    var child, children, i, length, nextNode, parentNode;\n    parentNode = this.childParentNode;\n    children = this.children;\n\n    if (length = children.length) {\n      nextNode = this.childrenNextNode;\n      i = length - 1;\n\n      while (child = children[i]) {\n        child.setHolder(this);\n        child.parentNode = parentNode;\n        child.setNextNode(nextNode);\n        child.attachParent();\n        nextNode = child.firstNode || nextNode;\n        i--;\n      }\n\n      child = children[0];\n      this.childNodes.parentNode = parentNode;\n    }\n  },\n  attachInvalidChildren: function attachInvalidChildren() {\n    var attachingIndexes, child, children, i, listIndex, nextNode, parentNode, prevIndex;\n    attachingIndexes = this.attachingIndexes;\n\n    if (attachingIndexes.length) {\n      this.attachingIndexes = [];\n\n      if (parentNode = this.childParentNode) {\n        nextNode = this.childrenNextNode;\n        children = this.children;\n        i = attachingIndexes.length - 1;\n        prevIndex = children.length - 1;\n\n        while (i >= 0) {\n          listIndex = attachingIndexes[i];\n          setNextNodes(children, nextNode, prevIndex, listIndex);\n          child = children[listIndex];\n          child.setHolder(this);\n          child.parentNode = parentNode;\n          child.attachParent();\n          nextNode = child.firstNode || child.nextNode;\n          prevIndex = listIndex - 1;\n          i--;\n        }\n\n        setNextNodes(children, nextNode, prevIndex, 0);\n        this.childNodes.parentNode = parentNode;\n      }\n    }\n  },\n  propagateChildNextNode: function propagateChildNextNode(child, nextNode) {\n    var children, index;\n    children = this.children;\n\n    if ((0, _isComponent.default)(child)) {\n      index = children.indexOf(child) - 1;\n    } else {\n      index = child - 1;\n    }\n\n    while (child = children[index]) {\n      child.setNextNode(nextNode);\n\n      if (child.firstNode) {\n        return;\n      }\n\n      index--;\n    }\n\n    if (!this.isTag && this.holder) {\n      this.holder.propagateChildNextNode(this, nextNode);\n    }\n  },\n  linkNextNode: function linkNextNode(child, oldNode, nextNode) {\n    var children, index;\n    children = this.children;\n\n    if ((0, _isComponent.default)(child)) {\n      index = children.indexOf(child) - 1;\n    } else {\n      index = child - 1;\n    }\n\n    while (index >= 0) {\n      child = children[index];\n\n      if (child.nextNode === oldNode) {\n        child.setNextNode(nextNode);\n      } else {\n        return;\n      }\n\n      index--;\n    }\n\n    if (!this.isTag && this.holder) {\n      this.holder.linkNextNode(this, oldNode, nextNode);\n    }\n  }\n};\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/component/ListMixin.coffee?");

/***/ }),

/***/ "./src/component/MVC.coffee":
/*!**********************************!*\
  !*** ./src/component/MVC.coffee ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _TranComponent2 = _interopRequireDefault(__webpack_require__(/*! ./TranComponent */ \"./src/component/TranComponent.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar MVC;\n\nvar _default = module.exports = MVC =\n/*#__PURE__*/\nfunction (_TranComponent) {\n  _inherits(MVC, _TranComponent);\n\n  function MVC(view, model) {\n    var _this;\n\n    _classCallCheck(this, MVC);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(MVC).call(this));\n    _this._view = view;\n    _this._model = model;\n    return _this;\n  }\n\n  return MVC;\n}(_TranComponent2.default);\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/component/MVC.coffee?");

/***/ }),

/***/ "./src/component/Nothing.coffee":
/*!**************************************!*\
  !*** ./src/component/Nothing.coffee ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _BaseComponent2 = _interopRequireDefault(__webpack_require__(/*! ./BaseComponent */ \"./src/component/BaseComponent.coffee\"));\n\nvar _dcUtil = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nvar Nothing;\n\nvar _default = module.exports = Nothing =\n/*#__PURE__*/\nfunction (_BaseComponent) {\n  _inherits(Nothing, _BaseComponent);\n\n  function Nothing() {\n    var _this;\n\n    _classCallCheck(this, Nothing);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Nothing).call(this));\n    _this.firstNode = null;\n    _this.family = {};\n    _this.baseComponent = _assertThisInitialized(_assertThisInitialized(_this));\n    return _this;\n  }\n\n  _createClass(Nothing, [{\n    key: \"invalidate\",\n    value: function invalidate() {\n      return this;\n    }\n  }, {\n    key: \"renderDom\",\n    value: function renderDom(oldBaseComponent) {\n      if (oldBaseComponent) {\n        oldBaseComponent.markRemovingDom();\n      }\n\n      this.valid = true;\n      this.node = [];\n      return this;\n    }\n  }, {\n    key: \"createDom\",\n    value: function createDom() {\n      return this.node = [];\n    }\n  }, {\n    key: \"attachParent\",\n    value: function attachParent() {\n      return this.node;\n    }\n  }, {\n    key: \"attachChildren\",\n    value: function attachChildren() {\n      return this.node;\n    }\n  }, {\n    key: \"markRemovingDom\",\n    value: function markRemovingDom() {\n      return this;\n    }\n  }, {\n    key: \"removeDom\",\n    value: function removeDom() {\n      return this;\n    }\n  }, {\n    key: \"removeNode\",\n    value: function removeNode() {}\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Nothing();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n      var addNewLine = arguments.length > 1 ? arguments[1] : undefined;\n      return (0, _dcUtil.newLine)(\"<Nothing/>\", indent, addNewLine);\n    }\n  }]);\n\n  return Nothing;\n}(_BaseComponent2.default);\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/component/Nothing.coffee?");

/***/ }),

/***/ "./src/component/Pick.coffee":
/*!***********************************!*\
  !*** ./src/component/Pick.coffee ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _toComponent = _interopRequireDefault(__webpack_require__(/*! ./toComponent */ \"./src/component/toComponent.coffee\"));\n\nvar _TranComponent2 = _interopRequireDefault(__webpack_require__(/*! ./TranComponent */ \"./src/component/TranComponent.coffee\"));\n\nvar _dcUtil = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nvar Pick;\n\nvar _default = module.exports = Pick =\n/*#__PURE__*/\nfunction (_TranComponent) {\n  _inherits(Pick, _TranComponent);\n\n  function Pick(host1, field, initialContent) {\n    var _this;\n\n    _classCallCheck(this, Pick);\n\n    var family, get, me, set;\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Pick).call(this));\n    _this.host = host1;\n    me = _assertThisInitialized(_assertThisInitialized(_this));\n\n    if (field == null) {\n      _this.field = field = 'content';\n    } else {\n      _this.field = field;\n    }\n\n    if (initialContent) {\n      _this._content = host[field] = (0, _toComponent.default)(initialContent);\n    } else {\n      _this._content = host[field] = (0, _toComponent.default)(host[field]);\n    }\n\n    _this.family = family = Object.assign({}, _this._content.family);\n    family[_this.dcid] = true;\n\n    if (Object.defineProperty) {\n      get = function get() {\n        return me._content;\n      };\n\n      set = function set(content) {\n        me.setContent(content);\n        return content;\n      };\n\n      Object.defineProperty(host, field, {\n        get: get,\n        set: set\n      });\n    }\n\n    return _this;\n  }\n\n  _createClass(Pick, [{\n    key: \"setContent\",\n    value: function setContent(content) {\n      var oldContent;\n      oldContent = this._content;\n\n      if (content === oldContent) {\n        return this;\n      } else {\n        this.invalidateTransform();\n        this.onSetContent(content, oldContent);\n        this._content = (0, _toComponent.default)(content);\n        return this;\n      }\n    }\n  }, {\n    key: \"onSetContent\",\n    value: function onSetContent(content, oldContent) {\n      return this;\n    }\n  }, {\n    key: \"getContentComponent\",\n    value: function getContentComponent() {\n      return this._content;\n    } // this probably should be overloaded by the subclass\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new this.constructor(this.host, this.field).copyEventListeners(this);\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var addNewLine = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';\n      return (0, _dcUtil.newLine)('', indent, addNewLine) + '<Pick:' + this.field + ': ' + this._content.toString(indent + 2, true) + '>';\n    }\n  }]);\n\n  return Pick;\n}(_TranComponent2.default);\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/component/Pick.coffee?");

/***/ }),

/***/ "./src/component/Tag.coffee":
/*!**********************************!*\
  !*** ./src/component/Tag.coffee ***!
  \**********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _dc = _interopRequireDefault(__webpack_require__(/*! ../dc */ \"./src/dc.coffee\"));\n\nvar _domUtil = __webpack_require__(/*! ../dom-util */ \"./src/dom-util.coffee\");\n\nvar _classFn = _interopRequireDefault(__webpack_require__(/*! ../property/classFn */ \"./src/property/classFn.coffee\"));\n\nvar _BaseComponent2 = _interopRequireDefault(__webpack_require__(/*! ./BaseComponent */ \"./src/component/BaseComponent.coffee\"));\n\nvar _toComponentArray = _interopRequireDefault(__webpack_require__(/*! ./toComponentArray */ \"./src/component/toComponentArray.coffee\"));\n\nvar _dcUtil = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nvar _ListMixin = _interopRequireDefault(__webpack_require__(/*! ./ListMixin */ \"./src/component/ListMixin.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _get(target, property, receiver) { if (typeof Reflect !== \"undefined\" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(receiver); } return desc.value; }; } return _get(target, property, receiver || target); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = _getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nvar Tag, addEventListenerMap, addHandlerToCallbackArray, attrToPropName, binaryInsert, cacheElement, cloneObject, createElement, domEventHandler, flow, funcString, newLine, react, styleFrom;\n\nvar _require = __webpack_require__(/*! ../property/style */ \"./src/property/style.coffee\");\n\nstyleFrom = _require.styleFrom;\n\nvar _require2 = __webpack_require__(/*! ../property/attrs */ \"./src/property/attrs.coffee\");\n\nattrToPropName = _require2.attrToPropName;\n\nvar _require3 = __webpack_require__(/*! ../property/events */ \"./src/property/events.coffee\");\n\ndomEventHandler = _require3.domEventHandler;\naddEventListenerMap = _require3.addEventListenerMap;\naddHandlerToCallbackArray = _require3.addHandlerToCallbackArray;\n\nvar _require4 = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nfuncString = _require4.funcString;\nnewLine = _require4.newLine;\ncloneObject = _require4.cloneObject;\n\nvar _require5 = __webpack_require__(/*! lazy-flow */ \"./packages/lazy-flow/index.js\");\n\nflow = _require5.flow;\nreact = _require5.react;\n\nvar _require6 = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nbinaryInsert = _require6.binaryInsert;\n\nvar _require7 = __webpack_require__(/*! dc-util/element-pool */ \"./packages/dc-util/element-pool.js\");\n\ncreateElement = _require7.createElement;\ncacheElement = _require7.cacheElement;\n\nvar _default = module.exports = Tag =\n/*#__PURE__*/\nfunction (_BaseComponent) {\n  _inherits(Tag, _BaseComponent);\n\n  _createClass(Tag, [{\n    key: \"FakeTag\",\n    // used for Tag.clone(...)\n    value: function FakeTag() {\n      return Tag;\n    }\n  }]);\n\n  function Tag(tagName, attrs, children) {\n    var _this;\n\n    _classCallCheck(this, Tag);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Tag).call(this));\n\n    if (!(_assertThisInitialized(_assertThisInitialized(_this)) instanceof Tag)) {\n      throw 'should use new SubclassComponent(...) with the subclass of Tag';\n    }\n\n    _this.isTag = true;\n\n    if (tagName && _typeof(tagName) === 'object') {\n      if (!children) {\n        children = attrs;\n      }\n\n      attrs = tagName;\n      tagName = attrs && attrs.tagName;\n      delete attrs.tagName;\n    }\n\n    tagName = tagName || 'div';\n    _this.tagName = tagName.toLowerCase();\n    _this.namespace = attrs.namespace;\n    children = children || attrs.children;\n    delete attrs.children; // initChildren must put before extendAttrs\n\n    _this.children = (0, _toComponentArray.default)(children);\n\n    _this.initListMixin();\n\n    _this.initProperties();\n\n    _this.extendAttrs(attrs);\n\n    return _possibleConstructorReturn(_this);\n  }\n\n  _createClass(Tag, [{\n    key: \"initProperties\",\n    value: function initProperties() {\n      var className, me;\n      this.hasActiveProperties = false;\n      this.cacheClassName = \"\";\n      this.className = className = (0, _classFn.default)();\n      me = this;\n      this.className.onInvalidate(function () {\n        if (className.valid) {\n          me.hasActiveProperties = true;\n          return me.invalidate();\n        }\n      });\n      this.hasActiveProps = false;\n      this.cacheProps = {};\n      this.props = {};\n      this.boundProps = {};\n      this['invalidateProps'] = {};\n      this.hasActiveNodeAttrs = false;\n      this.cacheNodeAttrs = {};\n      this.nodeAttrs = {};\n      this.boundNodeAttrs = {};\n      this['invalidateNodeAttrs'] = {};\n      this.hasActiveStyle = false;\n      this.cacheStyle = {};\n      this.style = {};\n      this.boundStyle = {};\n      this['invalidateStyle'] = {};\n\n      if (!this.domEventCallbackMap) {\n        this.domEventCallbackMap = {};\n      }\n\n      this.eventUpdateConfig = {};\n    }\n  }, {\n    key: \"extendAttrs\",\n    value: function extendAttrs(attrs) {\n      var className, i, j, key, len, len1, nodeAttrs, props, ref, style, styles, v, v0, value;\n      className = this.className;\n      style = this.style;\n      props = this.props;\n      nodeAttrs = this.nodeAttrs;\n\n      for (key in attrs) {\n        value = attrs[key];\n\n        if (key === 'style') {\n          // style is this.style\n          styles = styleFrom(value);\n\n          for (key in styles) {\n            value = styles[key];\n            this.setProp(key, value, style, 'Style');\n          }\n        } else if (key === 'class' || key === 'className') {\n          this.hasActiveProperties = true;\n\n          if (typeof value === 'function') {\n            value = value();\n          }\n\n          className.Object.assign(value); // dom event\n        } else if (key.slice(0, 2) === 'on') {\n          if (!value) {\n            continue;\n          } else if (typeof value === 'function') {\n            this.bindOne(key, value);\n          } else {\n            v0 = value[0];\n\n            if (v0 === 'before' || v0 === 'after') {\n              ref = value.slice(1);\n\n              for (i = 0, len = ref.length; i < len; i++) {\n                v = ref[i]; // value is an array of handlers\n\n                this.bindOne(key, v, v0 === 'before');\n              }\n            } else {\n              for (j = 0, len1 = value.length; j < len1; j++) {\n                v = value[j]; // value is an array of handlers\n\n                this.bindOne(key, v);\n              }\n            }\n          }\n        } else if (key.slice(0, 5) === 'attr_') {\n          this.setProp(key.slice(5), value, nodeAttrs, 'NodeAttrs');\n        } else if (key.slice(0, 3) === 'xxx') {\n          continue;\n        } else {\n          this.setProp(key, value, props, 'Props');\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"restoreCacheProperties\",\n    value: function restoreCacheProperties() {\n      var key, nodeAttrs, props, ref, ref1, ref2, style, value;\n      style = this.style;\n      props = this.props;\n      nodeAttrs = this.nodeAttrs;\n      this.hasActiveProperties = true;\n\n      if (this.className) {\n        this.hasActiveProperties = true;\n        this.cacheClassName = '';\n        this.className.valid = false;\n      }\n\n      ref = this.cachePropes;\n\n      for (key in ref) {\n        value = ref[key];\n\n        if (props[key] == null) {\n          this.hasActiveProps = true;\n          props[key] = value;\n        }\n      }\n\n      ref1 = this.cacheStyle;\n\n      for (key in ref1) {\n        value = ref1[key];\n\n        if (style[key] == null) {\n          this.hasActiveStyle = true;\n          style[key] = value;\n        }\n      }\n\n      ref2 = this.nodeAttrs;\n\n      for (key in ref2) {\n        value = ref2[key];\n\n        if (nodeAttrs[key] == null) {\n          this.hasActiveNodeAttrs = true;\n          nodeAttrs[key] = value;\n        }\n      }\n\n      this.hasActiveDomEvents = true;\n      return this;\n    }\n  }, {\n    key: \"prop\",\n    value: function prop() {\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return this._prop(args, this.props, 'Props');\n    }\n  }, {\n    key: \"css\",\n    value: function css() {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return this._prop(args, this.style, 'Style');\n    }\n  }, {\n    key: \"attr\",\n    value: function attr() {\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return this._prop(args, this.nodeAttrs, 'NodeAttrs');\n    }\n  }, {\n    key: \"_prop\",\n    value: function _prop(args, props, type) {\n      var key, prop, v;\n\n      if (args.length === 0) {\n        return props;\n      }\n\n      if (args.length === 1) {\n        prop = args[0];\n\n        if (typeof prop === 'string') {\n          if (props.hasOwnProperty(prop)) {\n            return (0, _domUtil.domValue)(props[prop], this);\n          } else {\n            return this['cache' + type][prop];\n          }\n        } else {\n          for (key in prop) {\n            v = prop[key];\n            this.setProp(key, v, props, type);\n          }\n        }\n      } else if (args.length === 2) {\n        if (type === 'NodeAttrs') {\n          this.setProp(args[0], args[1], props, type);\n        } else {\n          this.setProp(args[0], args[1], props, type);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"setProp\",\n    value: function setProp(prop, value, props, type) {\n      var bound, fn, me, oldValue;\n\n      if (type !== 'NodeAttrs') {\n        prop = attrToPropName(prop);\n      }\n\n      value = (0, _domUtil.domField)(value, this);\n      oldValue = props[prop];\n\n      if (value === oldValue) {\n        return this;\n      } else if (oldValue == null) {\n        if (typeof value === 'function') {\n          me = this;\n\n          this['invalidate' + type][prop] = fn = function fn() {\n            var bound;\n            me.addActivity(props, prop, type, true);\n\n            if (bound = me['bound' + type][prop]) {\n              bound.invalidate();\n            }\n\n            return props[prop] = value;\n          };\n\n          value.onInvalidate(fn);\n          this.addActivity(props, prop, type);\n          props[prop] = value;\n        } else if (value !== this['cache' + type][prop]) {\n          this.addActivity(props, prop, type);\n\n          if (bound = this['bound' + type][prop]) {\n            bound.invalidate();\n          }\n\n          props[prop] = value;\n        }\n      } else {\n        // do not need to check cache\n        // do not need check typeof value == 'function'\n        // else null # do nothing\n        if (typeof oldValue === 'function') {\n          oldValue.offInvalidate(this['invalidate' + type][prop]);\n        } // else null # do not need to offInvalidate old callback\n\n\n        if (typeof value === 'function') {\n          me = this;\n\n          this['invalidate' + type][prop] = fn = function fn() {\n            me.addActivity(props, prop, type, true);\n\n            if (bound = me['bound' + type][prop]) {\n              bound.invalidate();\n            }\n\n            return props[prop] = value;\n          }; // value will always be a reactive function after executing \"value = domField(value, this)\"\n\n\n          value.onInvalidate(fn);\n        } // else null # do not need  value.onInvalidate\n\n\n        if (bound = this['bound' + type][prop]) {\n          bound.invalidate();\n        }\n\n        props[prop] = value;\n      }\n\n      return this;\n    }\n  }, {\n    key: \"propBind\",\n    value: function propBind(prop) {\n      return this._propBind(prop, this.props, 'Props');\n    }\n  }, {\n    key: \"cssBind\",\n    value: function cssBind(prop) {\n      return this._propBind(prop, this.style, 'Style');\n    }\n  }, {\n    key: \"attrBind\",\n    value: function attrBind(prop) {\n      return this._propBind(prop, this.nodeAttrs, 'NodeAttrs');\n    }\n  }, {\n    key: \"_propBind\",\n    value: function _propBind(prop, props, type) {\n      var bound, boundProps;\n      boundProps = this['bound' + type];\n\n      if (bound = boundProps[prop]) {\n        return bound;\n      } else {\n        return boundProps[prop] = react(function () {\n          return this._prop([prop], props, type);\n        });\n      }\n    }\n  }, {\n    key: \"addActivity\",\n    value: function addActivity(props, prop, type) {\n      this['hasActive' + type] = true;\n      this.hasActiveProperties = true;\n\n      if (!this.node) {\n        return;\n      }\n\n      return this.invalidate();\n    }\n  }, {\n    key: \"bind\",\n    value: function bind(eventNames, handler, before) {\n      var eventName, i, isBefore, len;\n\n      if (!this.domEventCallbackMap) {\n        this.domEventCallbackMap = {};\n      }\n\n      if (arguments.length === 1) {\n        for (eventName in eventNames) {\n          handler = eventNames[eventName];\n          this.bind(eventName, handler);\n        }\n      } else {\n        var _eventNames$split = eventNames.split(/\\s*:\\s*/);\n\n        var _eventNames$split2 = _slicedToArray(_eventNames$split, 2);\n\n        eventNames = _eventNames$split2[0];\n        isBefore = _eventNames$split2[1];\n        eventNames = eventNames.split(/\\s+/);\n\n        for (i = 0, len = eventNames.length; i < len; i++) {\n          eventName = eventNames[i];\n          this.bindOne(eventName, handler, before || isBefore);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"bindOne\",\n    value: function bindOne(eventName, handler, before) {\n      var domEventCallbackMap, domEventCallbacks;\n\n      if (!handler) {\n        _dc.default.error('Tag.bind: handler is undefined for event: ' + eventName);\n      }\n\n      if (eventName.slice(0, 2) !== 'on') {\n        eventName = 'on' + eventName;\n      }\n\n      domEventCallbackMap = this.domEventCallbackMap || (this.domEventCallbackMap = {});\n      domEventCallbacks = domEventCallbackMap[eventName] || (domEventCallbackMap[eventName] = []);\n\n      if (this.node) {\n        // the event in addEventListenerMap do not execute node[eventName]\n        // e.g. https://developer.mozilla.org/en/docs/Web/Events/compositionstart\n        // [2] The event was fired in versions of Gecko before 9.0, but didn't have the DOM Level 3 attributes and methods.\n        // so it's necessary to addEventListener\n        if (addEventListenerMap[eventName]) {\n          node.addEventListener(eventName.slice(2), domEventHandler);\n        } else {\n          this.node[eventName] = domEventHandler;\n        }\n      } else {\n        this.hasActiveDomEvents = true;\n        this.hasActiveProperties = true;\n      }\n\n      addHandlerToCallbackArray(handler, domEventCallbacks, before);\n      return this;\n    }\n  }, {\n    key: \"unbind\",\n    value: function unbind(eventNames, handler) {\n      var domEventCallbackMap, domEventCallbacks, eventName, i, index, len, node;\n      eventNames = eventNames.split('\\s+');\n      domEventCallbackMap = this.domEventCallbackMap;\n\n      for (i = 0, len = eventNames.length; i < len; i++) {\n        eventName = eventNames[i];\n\n        if (eventName.slice(0, 2) !== 'on') {\n          eventName = 'on' + eventName;\n        }\n\n        domEventCallbacks = domEventCallbackMap[eventName];\n\n        if (!domEventCallbacks) {\n          continue;\n        }\n\n        index = domEventCallbacks.indexOf(handler);\n\n        if (index >= 0) {\n          domEventCallbacks.splice(index, 1);\n\n          if (!domEventCallbacks.length) {\n            domEventCallbackMap[eventName] = null;\n\n            if (node = this.node) {\n              node[prop] = null;\n              node.removeEventListener(domEventHandler);\n            }\n          }\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"addClass\",\n    value: function addClass() {\n      for (var _len4 = arguments.length, items = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        items[_key4] = arguments[_key4];\n      }\n\n      this.className.Object.assign(items);\n\n      if (this.node && !this.className.valid) {\n        this.hasActiveProperties = true;\n        this.invalidate();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeClass\",\n    value: function removeClass() {\n      var _this$className;\n\n      (_this$className = this.className).removeClass.apply(_this$className, arguments);\n\n      if (this.node && !this.className.valid) {\n        this.hasActiveProperties = true;\n        this.invalidate();\n      }\n\n      return this;\n    }\n  }, {\n    key: \"show\",\n    value: function show(display) {\n      if (typeof display === 'function') {\n        display = display();\n\n        if (display == null) {\n          display = '';\n        }\n      }\n\n      if (display == null) {\n        this.setProp('display', 'block', this.style, 'Style');\n      } else if (display === 'visible') {\n        this.setProp('visibility', 'visible', this.style, 'Style');\n      } else {\n        this.setProp('display', display, this.style, 'Style');\n      }\n\n      return this;\n    }\n  }, {\n    key: \"hide\",\n    value: function hide(display) {\n      if (typeof display === 'function') {\n        display = display();\n\n        if (display == null) {\n          display = '';\n        }\n      }\n\n      if (!display) {\n        this.setProp('display', 'none', this.style, 'Style');\n      } else if (display === 'hidden') {\n        this.setProp('visibility', 'hidden', this.style, 'Style');\n      } else {\n        this.setProp('display', display, this.style, 'Style');\n      }\n\n      return this;\n    }\n  }, {\n    key: \"showHide\",\n    value: function showHide(status, test, display) {\n      var fn, me, method, oldDisplay, style;\n      style = this.style;\n      test = (0, _domUtil.domField)(test, this);\n      oldDisplay = style.display;\n\n      if (!oldDisplay) {\n        this.addActivity(style, 'display', 'Style', this.node);\n      } else if (typeof oldDisplay === 'function' && oldDisplay.offInvalidate) {\n        oldDisplay.offInvalidate(this.invalidateStyle.display);\n      }\n\n      style.display = method = flow(test, oldDisplay, function () {\n        var d;\n\n        if ((typeof test === 'function' ? !!test() : !!test) === status) {\n          if (display) {\n            if (typeof display === 'function') {\n              return display();\n            } else {\n              return display;\n            }\n          } else if (oldDisplay != null) {\n            if (typeof oldDisplay === 'function') {\n              d = oldDisplay();\n            } else {\n              d = oldDisplay;\n            }\n\n            if (d !== 'none') {\n              return d;\n            } else {\n              return 'block';\n            }\n          } else {\n            return oldDisplay = 'block';\n          }\n        } else {\n          return 'none';\n        }\n      });\n      me = this;\n\n      this.invalidateStyle.display = fn = function fn() {\n        me.addActivity(style, 'display', 'Style', true);\n        return style.display = method;\n      };\n\n      method.onInvalidate(fn);\n      this.style = style;\n      return this;\n    }\n  }, {\n    key: \"refreshDom\",\n    value: function refreshDom(oldBaseComponent) {\n      this.renderDom(oldBaseComponent);\n      this.attachParent();\n    }\n  }, {\n    key: \"createDom\",\n    value: function createDom() {\n      var node;\n      this.valid = true;\n      this.node = this.firstNode = node = createElement(this.namespace, this.tagName, this.poolLabel);\n      node.component = this;\n      this.updateProperties();\n      this.createChildrenDom();\n      this.attachChildren();\n      return node;\n    }\n  }, {\n    key: \"updateDom\",\n    value: function updateDom() {\n      var child, i, len, namespace, node, ref;\n      this.valid = true;\n      namespace = this.namespace || \"http://www.w3.org/1999/xhtml\";\n\n      if (this.tagName !== this.node.tagName.toLowerCase() || namespace !== this.node.namespaceURI) {\n        node = this.node;\n        node.parentNode && node.parentNode.removeChild(node);\n        this.node = this.firstNode = node = createElement(this.namespace, this.tagName, this.poolLabel);\n        node.component = this;\n        this.childParentNode = null;\n        this.restoreCacheProperties();\n        this.updateProperties();\n        this.createChildrenDom();\n        this.holder.invalidateAttach(this);\n        ref = this.children;\n\n        for (i = 0, len = ref.length; i < len; i++) {\n          child = ref[i];\n          child.resetAttach();\n        }\n\n        this.attachChildren();\n        this.holder.propagateChildNextNode(this, node);\n        return node;\n      } else {\n        this.updateProperties();\n        this.updateChildrenDom();\n        this.attachChildren();\n        return this.node;\n      }\n    }\n  }, {\n    key: \"invalidateAttach\",\n    value: function invalidateAttach(child) {\n      var index;\n      index = this.children.indexOf(child);\n      binaryInsert(index, this.attachingIndexes);\n      this.attachValid = false;\n\n      if (this.valid) {\n        this.valid = false;\n        this.holder && this.holder.invalidateContent(this);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"updateProperties\",\n    value: function updateProperties() {\n      var cacheNodeAttrs, cacheProps, cacheStyle, callbackList, className, classValue, elementStyle, eventName, node, nodeAttrs, prop, props, ref, style, value;\n\n      if (!this.hasActiveProperties) {\n        return;\n      }\n\n      this.hasActiveProperties = false;\n      node = this.node;\n      className = this.className;\n\n      if (!className.valid) {\n        classValue = className.call(this);\n\n        if (classValue !== this.cacheClassName) {\n          this.cacheClassName = node.className = classValue;\n        }\n      }\n\n      if (this.hasActiveNodeAttrs) {\n        nodeAttrs = this.nodeAttrs;\n        cacheNodeAttrs = this.cacheNodeAttrs;\n        this.hasActiveNodeAttrs = false;\n\n        for (prop in nodeAttrs) {\n          value = nodeAttrs[prop];\n          delete nodeAttrs[prop];\n          value = (0, _domUtil.domValue)(value, this);\n          cacheNodeAttrs[prop] = node[prop] = value;\n          node.setAttribute(prop, value);\n        }\n      }\n\n      if (this.hasActiveProps) {\n        props = this.props;\n        cacheProps = this.cacheProps;\n        this.hasActiveProps = false;\n\n        for (prop in props) {\n          value = props[prop];\n          delete props[prop];\n          value = (0, _domUtil.domValue)(value, this);\n          cacheProps[prop] = node[prop] = value;\n        }\n      }\n\n      if (this.hasActiveStyle) {\n        style = this.style;\n        cacheStyle = this.cacheStyle;\n        this.hasActiveStyle = false;\n        elementStyle = node.style;\n\n        for (prop in style) {\n          value = style[prop];\n          delete style[prop];\n          value = (0, _domUtil.domValue)(value, this);\n          cacheStyle[prop] = elementStyle[prop] = value;\n        }\n      }\n\n      if (this.hasActiveDomEvents) {\n        ref = this.domEventCallbackMap;\n\n        for (eventName in ref) {\n          callbackList = ref[eventName];\n\n          if (callbackList && callbackList.length) {\n            // the event in addEventListenerMap do not execute node[eventName]\n            // e.g. https://developer.mozilla.org/en/docs/Web/Events/compositionstart\n            // [2] The event was fired in versions of Gecko before 9.0, but didn't have the DOM Level 3 attributes and methods.\n            // so it's necessary to addEventListener\n            if (addEventListenerMap[eventName]) {\n              node.addEventListener(eventName.slice(2), domEventHandler);\n            } else {\n              node[eventName] = domEventHandler;\n            }\n          }\n        }\n      }\n\n      this.hasActiveDomEvents = false;\n    }\n  }, {\n    key: \"setPoolLabel\",\n    value: function setPoolLabel(poolLabel) {\n      this.poolLabel = poolLabel;\n      return this;\n    }\n  }, {\n    key: \"generatePoolLabel\",\n    value: function generatePoolLabel() {\n      return '';\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      var node;\n\n      if (this.poolLabel && (node = this.node)) {\n        cacheElement(node, this.poolLabel);\n      }\n\n      _get(_getPrototypeOf(Tag.prototype), \"destroy\", this).call(this);\n\n      if (this.poolLabel && node) {\n        node.innerHTML = '';\n      }\n\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone(options) {\n      var FakeTag, attrs, domEventCallbacks, eventName, ref, result;\n      attrs = {\n        className: this.className.clone(),\n        style: Object.assign({}, this.cacheStyle, this.style)\n      };\n      Object.assign(attrs, this.cacheProps, this.props, this.cacheNodeAttrs, this.nodeAttrs);\n      ref = this.domEventCallbackMap;\n\n      for (eventName in ref) {\n        domEventCallbacks = ref[eventName];\n        attrs[eventName] = domEventCallbacks.slice(0);\n      }\n\n      FakeTag = this.FakeTag();\n      result = new FakeTag(this.tagName, attrs, []);\n      result.__proto__ = this.__proto__;\n      result.constructor = this.constructor;\n      result.cloneChildrenFrom(this, options);\n      result.copyEventListeners(this);\n      return result.setupCloneComponent(this, options);\n    }\n  }, {\n    key: \"setupCloneComponent\",\n    value: function setupCloneComponent(srcTag, options) {\n      return this.setReactive();\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var addNewLine = arguments.length > 1 ? arguments[1] : undefined;\n      var child, children, i, key, len, ref, ref1, ref2, s, v, value;\n      s = newLine(\"<\".concat(this.tagName), indent, addNewLine);\n      ref = this.props;\n\n      for (key in ref) {\n        value = ref[key];\n        s += ' ' + key + '=' + funcString(value);\n      }\n\n      if (this.hasActiveStyle) {\n        s += ' style={';\n        ref1 = this.style;\n\n        for (key in ref1) {\n          value = ref1[key];\n\n          if (typeof value === 'string') {\n            s += value;\n          } else {\n            for (key in value) {\n              v = value[key];\n              s += ' ' + key + '=' + funcString(v);\n            }\n          }\n        }\n\n        s += '}';\n      }\n\n      s += '>';\n      children = this.children;\n\n      if (children.length > 1) {\n        ref2 = this.children;\n\n        for (i = 0, len = ref2.length; i < len; i++) {\n          child = ref2[i];\n          s += child.toString(indent + 2, true);\n        }\n\n        return s += newLine(\"</\".concat(this.tagName, \">\"), indent + 2, true);\n      } else {\n        if (children.length === 1) {\n          s += children[0].toString(indent + 2);\n        }\n\n        return s += newLine(\"</\".concat(this.tagName, \">\"), indent + 2);\n      }\n    }\n  }]);\n\n  return Tag;\n}(_BaseComponent2.default);\n\nexports.default = _default;\n(0, _dcUtil.mixin)(Tag.prototype, _ListMixin.default);\n\n//# sourceURL=webpack:///./src/component/Tag.coffee?");

/***/ }),

/***/ "./src/component/TestComponent.coffee":
/*!********************************************!*\
  !*** ./src/component/TestComponent.coffee ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _TranComponent2 = _interopRequireDefault(__webpack_require__(/*! ./TranComponent */ \"./src/component/TranComponent.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nvar TestComponent;\n\nvar _default = module.exports = TestComponent =\n/*#__PURE__*/\nfunction (_TranComponent) {\n  _inherits(TestComponent, _TranComponent);\n\n  function TestComponent(test) {\n    var _this;\n\n    _classCallCheck(this, TestComponent);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(TestComponent).call(this));\n    _this.test = test;\n\n    _assertThisInitialized(_assertThisInitialized(_this));\n\n    return _this;\n  }\n\n  return TestComponent;\n}(_TranComponent2.default);\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/component/TestComponent.coffee?");

/***/ }),

/***/ "./src/component/Text.coffee":
/*!***********************************!*\
  !*** ./src/component/Text.coffee ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _BaseComponent2 = _interopRequireDefault(__webpack_require__(/*! ./BaseComponent */ \"./src/component/BaseComponent.coffee\"));\n\nvar _dcUtil = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nvar _domUtil = __webpack_require__(/*! ../dom-util */ \"./src/dom-util.coffee\");\n\nvar _attrs = __webpack_require__(/*! ../property/attrs */ \"./src/property/attrs.coffee\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nvar Text, hasTextContent;\n\nif ('textContent' in document.documentElement) {\n  hasTextContent = true;\n} else {\n  hasTextContent = false;\n}\n\nvar _default = module.exports = Text = function () {\n  var Text =\n  /*#__PURE__*/\n  function (_BaseComponent) {\n    _inherits(Text, _BaseComponent);\n\n    function Text(text) {\n      var _this;\n\n      _classCallCheck(this, Text);\n\n      var get, me, set;\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(Text).call(this));\n\n      _this.setText(text);\n\n      if (Object.defineProperty) {\n        me = _assertThisInitialized(_assertThisInitialized(_this));\n\n        get = function get() {\n          return me._text;\n        };\n\n        set = function set(text) {\n          me.setText(text);\n          return text;\n        };\n\n        Object.defineProperty(_assertThisInitialized(_assertThisInitialized(_this)), 'text', {\n          get: get,\n          set: set\n        });\n      }\n\n      _this.family = {};\n      _this.family[_this.dcid] = true;\n\n      _assertThisInitialized(_assertThisInitialized(_this));\n\n      return _this;\n    }\n\n    _createClass(Text, [{\n      key: \"setText\",\n      value: function setText(text) {\n        this.text = text;\n        return this;\n      }\n    }, {\n      key: \"createDom\",\n      value: function createDom() {\n        var node, text;\n        this.valid = true;\n        text = (0, _domUtil.domValue)(this.text, this);\n        node = document.createTextNode(text);\n        node.component = this;\n        this.node = node;\n        this.firstNode = node;\n        return node;\n      }\n    }, {\n      key: \"updateDom\",\n      value: function updateDom() {\n        var node, text;\n        node = this.node;\n        this.valid = true;\n        text = (0, _domUtil.domValue)(this.text, this);\n\n        if (hasTextContent) {\n          if (text !== node.textContent) {\n            node.textContent = text;\n          }\n        } else {\n          if (text !== node.innerText) {\n            node.innerText = text;\n          }\n        }\n\n        return node;\n      }\n    }, {\n      key: \"clone\",\n      value: function clone() {\n        var result;\n        result = new this.constructor(this.text);\n        return result.copyEventListeners(this);\n      }\n    }, {\n      key: \"toString\",\n      value: function toString() {\n        var indent = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 2;\n        var addNewLine = arguments.length > 1 ? arguments[1] : undefined;\n        return (0, _dcUtil.newLine)((0, _dcUtil.funcString)(this.text), indent, addNewLine);\n      }\n    }]);\n\n    return Text;\n  }(_BaseComponent2.default);\n\n  ;\n  Text.prototype.isText = true;\n  return Text;\n}.call(void 0);\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/component/Text.coffee?");

/***/ }),

/***/ "./src/component/TranComponent.coffee":
/*!********************************************!*\
  !*** ./src/component/TranComponent.coffee ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _Component2 = _interopRequireDefault(__webpack_require__(/*! ./Component */ \"./src/component/Component.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar TranComponent;\n\nvar _default = module.exports = TranComponent = function () {\n  var TranComponent =\n  /*#__PURE__*/\n  function (_Component) {\n    _inherits(TranComponent, _Component);\n\n    function TranComponent() {\n      var _this;\n\n      _classCallCheck(this, TranComponent);\n\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(TranComponent).call(this));\n      _this.transformValid = false;\n      return _this;\n    }\n\n    _createClass(TranComponent, [{\n      key: \"invalidate\",\n      value: function invalidate() {\n        if (this.valid) {\n          this.valid = false;\n          this.holder && this.holder.invalidateContent(this);\n        }\n\n        return this;\n      }\n    }, {\n      key: \"refreshDom\",\n      value: function refreshDom(oldBaseComponent) {\n        this.renderDom(oldBaseComponent);\n        return this.attachParent();\n      }\n    }, {\n      key: \"renderDom\",\n      value: function renderDom(oldBaseComponent) {\n        var BaseComponent, content;\n        this.emit('willRenderDom');\n        this.valid = true;\n        this.attachValid = true;\n\n        if (!this.transformValid) {\n          this.transformValid = true;\n          content = this.content;\n\n          if (content && content.holder === this) {\n            this.content.holder = null;\n          }\n\n          this.content = this.getContentComponent();\n          this.content.clearRemoving();\n        }\n\n        content = this.content;\n        content.holder = this;\n        content.parentNode = this.parentNode;\n        content.nextNode = this.nextNode;\n        content.renderDom(oldBaseComponent);\n        BaseComponent = content.BaseComponent;\n        this.BaseComponent = BaseComponent;\n        this.node = BaseComponent.node;\n        this.firstNode = BaseComponent.firstNode;\n\n        if (!this.node.parentNode) {\n          content.attachValid = false;\n          this.invalidateAttach(content);\n        }\n\n        this.emit('didRenderDom');\n        return this;\n      }\n    }, {\n      key: \"markRemovingDom\",\n      value: function markRemovingDom() {\n        this.removing = true;\n        this.holder = null;\n        dc.removingChildren[this.dcid] = this;\n\n        if (this.content) {\n          this.content.markRemoving();\n        }\n\n        return this;\n      }\n    }, {\n      key: \"markRemoving\",\n      value: function markRemoving() {\n        this.removing = true;\n\n        if (this.content) {\n          this.content.markRemoving();\n        }\n      }\n    }, {\n      key: \"clearRemoving\",\n      value: function clearRemoving() {\n        this.removing = this.removed = false;\n\n        if (this.content) {\n          this.content.clearRemoving();\n        }\n      }\n    }, {\n      key: \"removeDom\",\n      value: function removeDom() {\n        if (this.removing) {\n          this.removing = false;\n          this.removed = true;\n\n          if (this.content) {\n            this.content.removeDom();\n          }\n        }\n\n        return this;\n      }\n    }, {\n      key: \"removeNode\",\n      value: function removeNode() {\n        this.removing = false;\n        this.removed = true;\n\n        if (this.content) {\n          this.content.removeNode();\n        }\n      }\n    }, {\n      key: \"attachParent\",\n      value: function attachParent() {\n        var content;\n\n        if (!this.attachValid) {\n          this.attachValid = true;\n          content = this.content;\n          content.parentNode = this.parentNode;\n          content.nextNode = this.nextNode;\n          content.attachParent();\n        }\n      }\n    }, {\n      key: \"propagateChildNextNode\",\n      value: function propagateChildNextNode(child, nextNode) {\n        if (this.holder) {\n          this.holder.propagateChildNextNode(this, nextNode);\n        }\n      }\n    }, {\n      key: \"linkNextNode\",\n      value: function linkNextNode(child, oldNode, nextNode) {\n        if (this.holder) {\n          this.holder.linkNextNode(this, oldNode, nextNode);\n        }\n      }\n    }, {\n      key: \"resetAttach\",\n      value: function resetAttach() {\n        this.attachValid = false;\n        return this.content.resetAttach();\n      }\n    }]);\n\n    return TranComponent;\n  }(_Component2.default);\n\n  ;\n  TranComponent.prototype.isTranComponent = true;\n  return TranComponent;\n}.call(void 0);\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/component/TranComponent.coffee?");

/***/ }),

/***/ "./src/component/index.coffee":
/*!************************************!*\
  !*** ./src/component/index.coffee ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _route = _interopRequireDefault(__webpack_require__(/*! ./route */ \"./src/component/route.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _exports;\n\nmodule.exports = _exports = {\n  isComponent: __webpack_require__(/*! ./isComponent */ \"./src/component/isComponent.coffee\"),\n  toComponent: __webpack_require__(/*! ./toComponent */ \"./src/component/toComponent.coffee\"),\n  toComponentArray: __webpack_require__(/*! ./toComponentArray */ \"./src/component/toComponentArray.coffee\"),\n  Component: __webpack_require__(/*! ./Component */ \"./src/component/Component.coffee\"),\n  BaseComponent: __webpack_require__(/*! ./BaseComponent */ \"./src/component/BaseComponent.coffee\"),\n  ListMixin: __webpack_require__(/*! ./ListMixin */ \"./src/component/ListMixin.coffee\"),\n  List: __webpack_require__(/*! ./List */ \"./src/component/List.coffee\"),\n  Tag: __webpack_require__(/*! ./Tag */ \"./src/component/Tag.coffee\"),\n  Text: __webpack_require__(/*! ./Text */ \"./src/component/Text.coffee\"),\n  Comment: __webpack_require__(/*! ./Comment */ \"./src/component/Comment.coffee\"),\n  Cdata: __webpack_require__(/*! ./Cdata */ \"./src/component/Cdata.coffee\"),\n  Html: __webpack_require__(/*! ./Html */ \"./src/component/Html.coffee\"),\n  Nothing: __webpack_require__(/*! ./Nothing */ \"./src/component/Nothing.coffee\"),\n  TranComponent: __webpack_require__(/*! ./TranComponent */ \"./src/component/TranComponent.coffee\"),\n  TestComponent: __webpack_require__(/*! ./TestComponent */ \"./src/component/TestComponent.coffee\"),\n  If: __webpack_require__(/*! ./If */ \"./src/component/If.coffee\"),\n  MVC: __webpack_require__(/*! ./MVC */ \"./src/component/MVC.coffee\"),\n  Case: __webpack_require__(/*! ./Case */ \"./src/component/Case.coffee\"),\n  Func: __webpack_require__(/*! ./Func */ \"./src/component/Func.coffee\"),\n  Pick: __webpack_require__(/*! ./Pick */ \"./src/component/Pick.coffee\"),\n  Defer: __webpack_require__(/*! ./Defer */ \"./src/component/Defer.coffee\"),\n  Route: _route.default.Route,\n  route: _route.default\n};\nvar _default = _exports;\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/component/index.coffee?");

/***/ }),

/***/ "./src/component/isComponent.coffee":
/*!******************************************!*\
  !*** ./src/component/isComponent.coffee ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n// do not try to use item instanceof Component again\n// tried, but it will fail under the module system\n// sometimes Component  from \"path/to/Component\")\n// is not the same as in the original Component\nvar _default = module.exports = function (item) {\n  return item && item.render != null;\n};\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/component/isComponent.coffee?");

/***/ }),

/***/ "./src/component/route.coffee":
/*!************************************!*\
  !*** ./src/component/route.coffee ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _TranComponent2 = _interopRequireDefault(__webpack_require__(/*! ./TranComponent */ \"./src/component/TranComponent.coffee\"));\n\nvar _isComponent = _interopRequireDefault(__webpack_require__(/*! ./isComponent */ \"./src/component/isComponent.coffee\"));\n\nvar _toComponent = _interopRequireDefault(__webpack_require__(/*! ./toComponent */ \"./src/component/toComponent.coffee\"));\n\nvar _dcUtil = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/*\n  route '...', ((match, route) ->\n          ...\n          route ...),\n      ...\n      otherwise\n      baseIndex\n  * match: {items, basePath, segment, leftPath, childBase}\n  handler = (match, route) ->\n  otherwiseHandler = (route) ->\n   :user # yes: .../xxx  no: .../xxx/\n  :user/  # yes .../xxx/ no /xxx\n  :user:\\w+/ # yes: .../xyz\n  :user:(a\\d*)/**\n  :user**\n  :user/name=:name\n  **\n  *\n */\nvar Route,\n    _route,\n    getRoutePattern,\n    matchRoute,\n    navigate,\n    navigateTo,\n    processPiecePatterns,\n    processRouteItem,\n    route,\n    splice = [].splice;\n\nvar _default = module.exports = route = function route() {\n  var _ref, _ref2, _splice$call, _splice$call2;\n\n  for (var _len = arguments.length, routeList = new Array(_len), _key = 0; _key < _len; _key++) {\n    routeList[_key] = arguments[_key];\n  }\n\n  var baseIndex, otherwise, ref;\n  ref = routeList, (_ref = ref, _ref2 = _toArray(_ref), routeList = _ref2.slice(0), _ref), (_splice$call = splice.call(routeList, -2), _splice$call2 = _slicedToArray(_splice$call, 2), otherwise = _splice$call2[0], baseIndex = _splice$call2[1], _splice$call);\n  return _route(routeList, otherwise, baseIndex, 0);\n};\n\nexports.default = _default;\n\n_route = function _route(routeList, otherwise, baseIndex, defaultBaseIndex) {\n  var i, len, routeList2;\n\n  if (typeof baseIndex === 'function') {\n    routeList.push(otherwise);\n    routeList.push(baseIndex);\n    otherwise = null;\n    baseIndex = defaultBaseIndex;\n  } else if ((0, _isComponent.default)(baseIndex)) {\n    routeList.push(otherwise);\n    otherwise = baseIndex;\n    baseIndex = defaultBaseIndex;\n  } else if (baseIndex && !(0, _isComponent.default)(baseIndex) && baseIndex.otherwise) {\n    routeList.push(otherwise);\n    otherwise = baseIndex.otherwise;\n    baseIndex = defaultBaseIndex;\n  } else {\n    baseIndex = baseIndex >>> 0;\n\n    if (otherwise && !(0, _isComponent.default)(otherwise) && otherwise.otherwise) {\n      otherwise = otherwise.otherwise;\n    }\n  }\n\n  len = routeList.length;\n\n  if (!(0, _dcUtil.isEven)(len)) {\n    throw new Error('route parameter error: missing matched handler');\n  }\n\n  if (len < 2 || typeof routeList[len - 1] !== 'function') {\n    throw new Error('route parameter error:\\n  expect route(pattern, handler, pattern, handler, ..., otherwise, baseIndex)');\n  }\n\n  routeList2 = [];\n  i = 0;\n\n  while (i < len) {\n    routeList2.push([routeList[i], routeList[i + 1]]);\n    i += 2;\n  }\n\n  return new Route(routeList2, otherwise, baseIndex);\n};\n\nroute._navigateTo = navigateTo = function navigateTo(oldPath, path) {\n  var baseIndex = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var base, upCount;\n  path = '' + path;\n\n  if (path[0] !== '/') {\n    upCount = 0;\n\n    while (path) {\n      if (path.slice(0, 2) === './') {\n        path = path.slice(2);\n      } else if (path.slice(0, 3) === '../') {\n        path = path.slice(3);\n        upCount++;\n      } else {\n        break;\n      }\n    }\n\n    baseIndex -= upCount;\n\n    if (baseIndex < 0) {\n      baseIndex = 0;\n    }\n\n    base = oldPath.split('/').slice(0, baseIndex).join('/') + '/';\n\n    if (base === '/') {\n      base = '';\n    }\n\n    return path = base + path;\n  } else {\n    return path = path.slice(1); // clear start '/'\n  }\n};\n\nnavigate = function navigate(baseIndex) {\n  return function (path) {\n    var match, oldPath;\n    oldPath = window.history && window.history.pushState ? decodeURI(location.pathname + location.search).replace(/\\?(.*)$/, '') : (match = location.href.match(/#(.*)$/)) ? match[1] : ''; // remove GET params\n\n    navigateTo(oldPath, path, baseIndex);\n\n    if (window.history && window.history.pushState) {\n      history.pushState(null, null, path);\n    } else {\n      location.href = location.href.replace(/#(.*)$/, '') + '#' + path;\n    }\n\n    return path;\n  };\n};\n\nroute.to = navigate(0);\n\nroute.Route = Route =\n/*#__PURE__*/\nfunction (_TranComponent) {\n  _inherits(Route, _TranComponent);\n\n  function Route(routeList1, otherwise1, baseIndex1) {\n    var _this;\n\n    _classCallCheck(this, Route);\n\n    var j, len1, patternRoute;\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Route).call(this));\n    _this.routeList = routeList1;\n    _this.otherwise = otherwise1;\n    _this.baseIndex = baseIndex1;\n\n    for (j = 0, len1 = routeList.length; j < len1; j++) {\n      patternRoute = routeList[j];\n      patternRoute[0] = getRoutePattern(patternRoute[0]);\n    }\n\n    _this.otherwise = (0, _toComponent.default)(otherwise);\n    return _possibleConstructorReturn(_this);\n  }\n\n  _createClass(Route, [{\n    key: \"getContentComponent\",\n    value: function getContentComponent() {\n      var component, j, len1, path, patternRoute, ref;\n      path = this.getPath();\n      ref = this.routeList;\n\n      for (j = 0, len1 = ref.length; j < len1; j++) {\n        patternRoute = ref[j];\n\n        if (component = processRouteItem(patternRoute, path, this.baseIndex)) {\n          return component;\n        }\n      }\n\n      return this.otherwise;\n    }\n  }, {\n    key: \"getPath\",\n    value: function getPath() {\n      var match;\n\n      if (window.history && window.history.pushState) {\n        return decodeURI(location.pathname + location.search).replace(/\\?(.*)$/, ''); // remove GET params\n      } else if (match = location.href.match(/#(.*)$/)) {\n        return match[1];\n      } else {\n        return '';\n      }\n    }\n  }]);\n\n  return Route;\n}(_TranComponent2.default);\n\nroute._processRouteItem = processRouteItem = function processRouteItem(patternRoute, path, baseIndex) {\n  var childRoute, handler, match, pattern, test;\n\n  var _patternRoute = _slicedToArray(patternRoute, 2);\n\n  pattern = _patternRoute[0];\n  handler = _patternRoute[1];\n\n  if (pattern instanceof Array) {\n    var _pattern = pattern;\n\n    var _pattern2 = _slicedToArray(_pattern, 2);\n\n    pattern = _pattern2[0];\n    test = _pattern2[1];\n  }\n\n  match = matchRoute(pattern, path, baseIndex);\n\n  if (!match || test && !(match = test(match, path, baseIndex))) {\n    return;\n  }\n\n  childRoute = function childRoute() {\n    var _ref3, _ref4, _splice$call3, _splice$call4;\n\n    for (var _len2 = arguments.length, routeList = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      routeList[_key2] = arguments[_key2];\n    }\n\n    var baseIndex, otherwise, ref;\n    ref = routeList, (_ref3 = ref, _ref4 = _toArray(_ref3), routeList = _ref4.slice(0), _ref3), (_splice$call3 = splice.call(routeList, -2), _splice$call4 = _slicedToArray(_splice$call3, 2), otherwise = _splice$call4[0], baseIndex = _splice$call4[1], _splice$call3);\n    return _route(routeList, otherwise, baseIndex, match.base);\n  };\n\n  childRoute.to = navigate(match.base);\n  return (0, _toComponent.default)(handler(match, childRoute));\n};\n\nroute._processPiecePatterns = processPiecePatterns = function processPiecePatterns(segmentPattern, params, nonameRegExpIndex) {\n  var ch, i, key, len, pieces, start;\n  i = 0;\n  len = segmentPattern.length;\n  pieces = [];\n\n  while (ch = segmentPattern[i]) {\n    start = i;\n\n    if (ch === ':') {\n      ch = segmentPattern[++i];\n\n      if (!ch.match(/[A-Za-z_$]/)) {\n        throw new Error(\"route pattern error: expect a parameter identifier \".concat(segmentPattern));\n      }\n\n      ch = segmentPattern[++i];\n\n      while (ch && ch.match(/[$\\w]/)) {\n        ch = segmentPattern[++i];\n      }\n\n      if (i === start + 1) {\n        throw new Error(\"route pattern error: expect a parameter identifier \".concat(segmentPattern));\n      }\n\n      key = segmentPattern.slice(start + 1, i);\n\n      if (params[key]) {\n        throw new Error('route pattern error: repeated parameter name');\n      } else {\n        params[key] = true;\n      }\n\n      if (ch === '(') {\n        start = i;\n\n        if (i = (0, _dcUtil.matchCurvedString)(segmentPattern, i)) {\n          if (start + 1 === i - 1) {\n            throw new Error('route pattern error: empty regexp: ()');\n          }\n\n          pieces.push({\n            key: key,\n            pattern: new RegExp(segmentPattern.slice(start + 1, i - 1))\n          });\n          ch = segmentPattern[i];\n        } else {\n          throw new Error('route pattern error: missing ) for regexp');\n        }\n      } else {\n        pieces.push({\n          key: key,\n          pattern: new RegExp('\\\\w+')\n        });\n        ++i;\n      }\n    } else if (ch === '(') {\n      if (i = (0, _dcUtil.matchCurvedString)(segmentPattern, i)) {\n        if (start + 1 === i - 1) {\n          throw new Error('route pattern error: empty regexp: ()');\n        }\n\n        pieces.push({\n          key: nonameRegExpIndex++,\n          pattern: new RegExp(segmentPattern.slice(start + 1, i - 1))\n        });\n      } else {\n        throw new Error('route pattern error: missing ) for regexp');\n      }\n    } else {\n      ++i;\n\n      while ((ch = segmentPattern[i]) && ch !== ':' && ch !== '(') {\n        i++;\n      }\n\n      pieces.push({\n        pattern: segmentPattern.slice(start, i)\n      });\n    }\n  }\n\n  return [pieces, nonameRegExpIndex];\n};\n\nroute._getRoutePattern = getRoutePattern = function getRoutePattern(pattern) {\n  var absolute, atHead, endSlash, i, len, moreComing, nonameRegExpIndex, params, pieces, segment, segmentPatterns, segments, upCount;\n  pattern = '' + pattern;\n\n  if (pattern.match(/\\\\\\//)) {\n    new Error('should not include /\\\\\\// in pattern');\n  }\n\n  if (pattern === '') {\n    segments = [];\n  } else {\n    segments = pattern.split('/'); // '' at head or end will be processed in the loop\n  }\n\n  upCount = 0;\n  absolute = false;\n  atHead = true;\n  endSlash = false;\n  moreComing = false;\n  segmentPatterns = [];\n  params = {};\n  len = segments.length;\n  i = 0;\n  nonameRegExpIndex = 0;\n\n  while (i < len) {\n    segment = segments[i++];\n\n    if (segment === '.') {\n      if (atHead) {\n        continue;\n      } else {\n        throw new Error('route pattern error: do not use ./ pattern except the start');\n      }\n    } else if (segment === '..') {\n      if (atHead) {\n        upCount++;\n        continue;\n      } else {\n        throw new Error('route pattern error: do not use ../ except the start');\n      }\n    } else if (segment === '') {\n      if (atHead) {\n        absolute = true;\n      } else if (i === len) {\n        endSlash = true;\n      } else {\n        throw new Error('route pattern error: do not use ../ except the start');\n      }\n    } else if (segment === '*') {\n      segmentPatterns.push('*');\n    } else if (segment === '**') {\n      if (i === len) {\n        moreComing = true;\n      } else {\n        throw new Error('route pattern error: do not use ** except the last segment');\n      }\n    } else {\n      var _processPiecePatterns = processPiecePatterns(segment, params, nonameRegExpIndex);\n\n      var _processPiecePatterns2 = _slicedToArray(_processPiecePatterns, 2);\n\n      pieces = _processPiecePatterns2[0];\n      nonameRegExpIndex = _processPiecePatterns2[1];\n      segmentPatterns.push(pieces);\n    }\n\n    atHead = false;\n  }\n\n  return {\n    segmentPatterns: segmentPatterns,\n    absolute: absolute,\n    upCount: upCount,\n    endSlash: endSlash,\n    moreComing: moreComing\n  };\n};\n\nroute._matchRoute = matchRoute = function matchRoute(pattern, path, baseIndex) {\n  var base, basePath, i, items, j, k, leftPath, len, len1, len2, m, matchIndex, pathSegment, pathSegments, piece, piecePattern, ref, segmentPattern, segmentStr, segments;\n\n  if (pattern.endSlash && path[path.length - 1] !== '/') {\n    return;\n  }\n\n  if (pattern.absolute) {\n    baseIndex = 0;\n  } else {\n    baseIndex -= pattern.upCount;\n\n    if (baseIndex < 0) {\n      baseIndex = 0;\n    }\n  }\n\n  if (path === '/' || path === '') {\n    pathSegments = [];\n  } else {\n    pathSegments = path.split('/');\n\n    if (path[0] === '') {\n      pathSegments.shift();\n    }\n  }\n\n  len = pathSegments.length;\n  base = baseIndex;\n  items = {};\n  segments = [];\n  ref = pattern.segmentPatterns;\n\n  for (i = j = 0, len1 = ref.length; j < len1; i = ++j) {\n    segmentPattern = ref[i];\n\n    if (base >= len) {\n      return;\n    }\n\n    if (segmentPattern === '*') {\n      segments.push(pathSegments[base]);\n      base++;\n      continue;\n    }\n\n    matchIndex = 0;\n    segmentStr = pathSegment = pathSegments[base];\n\n    for (k = 0, len2 = segmentPattern.length; k < len2; k++) {\n      piece = segmentPattern[k];\n      piecePattern = piece.pattern;\n\n      if (typeof piecePattern === 'string') {\n        if (pathSegment.indexOf(piecePattern) === 0) {\n          pathSegment = pathSegment.slice(piecePattern.length);\n          matchIndex += piecePattern.length;\n        } else {\n          break;\n        }\n      } else {\n        if (m = pathSegment.match(piecePattern)) {\n          items[piece.key] = m;\n          matchIndex += m[0].length;\n        } else {\n          break;\n        }\n      }\n    }\n\n    if (matchIndex !== segmentStr.length) {\n      return;\n    }\n\n    segments.push(segmentStr);\n    base++;\n  }\n\n  if (base !== len && !pattern.moreComing) {\n    return;\n  }\n\n  basePath = '/' + pathSegments.slice(0, baseIndex + 1).join('/') + '/';\n  leftPath = '/' + pathSegments.slice(base).join('/');\n  return {\n    items: items,\n    basePath: basePath,\n    segments: segments,\n    leftPath: leftPath,\n    base: base\n  };\n};\n\n//# sourceURL=webpack:///./src/component/route.coffee?");

/***/ }),

/***/ "./src/component/toComponent.coffee":
/*!******************************************!*\
  !*** ./src/component/toComponent.coffee ***!
  \******************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _isComponent = _interopRequireDefault(__webpack_require__(/*! ./isComponent */ \"./src/component/isComponent.coffee\"));\n\nvar _Nothing = _interopRequireDefault(__webpack_require__(/*! ./Nothing */ \"./src/component/Nothing.coffee\"));\n\nvar _Text = _interopRequireDefault(__webpack_require__(/*! ./Text */ \"./src/component/Text.coffee\"));\n\nvar _lazyFlow = __webpack_require__(/*! lazy-flow */ \"./packages/lazy-flow/index.js\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _toComponent;\n\nvar _default = module.exports = _toComponent = function toComponent(item) {\n  var Func, List, component, e;\n\n  if ((0, _isComponent.default)(item)) {\n    return item;\n  } else if (typeof item === 'function') {\n    return new _Text.default(item);\n  } else if (item instanceof Array) {\n    List = __webpack_require__(/*! ./List */ \"./src/component/List.coffee\"); // avoid loop require\n\n    return new List(function () {\n      var i, len, results;\n      results = [];\n\n      for (i = 0, len = item.length; i < len; i++) {\n        e = item[i];\n        results.push(_toComponent(e));\n      }\n\n      return results;\n    }());\n  } else if (item == null) {\n    return new _Nothing.default();\n  } else if (item.then && item.catch) {\n    Func = __webpack_require__(/*! ./Func */ \"./src/component/Func.coffee\"); // avoid loop require\n\n    component = new Func((0, _lazyFlow.react)(function () {\n      return component.promiseResult;\n    }));\n    item.then(function (value) {\n      component.promiseResult = value;\n      return component.invalideTransform();\n    }).catch(function (error) {\n      component.promiseResult = error;\n      return component.invalideTransform();\n    });\n    return component;\n  } else {\n    return new _Text.default(item);\n  }\n};\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/component/toComponent.coffee?");

/***/ }),

/***/ "./src/component/toComponentArray.coffee":
/*!***********************************************!*\
  !*** ./src/component/toComponentArray.coffee ***!
  \***********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _toComponent = _interopRequireDefault(__webpack_require__(/*! ./toComponent */ \"./src/component/toComponent.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar toComponentArray;\n\nvar _default = module.exports = toComponentArray = function toComponentArray(item) {\n  var e, i, len, results;\n\n  if (!item) {\n    return [];\n  } else if (item instanceof Array) {\n    results = [];\n\n    for (i = 0, len = item.length; i < len; i++) {\n      e = item[i];\n      results.push((0, _toComponent.default)(e));\n    }\n\n    return results;\n  } else {\n    return [(0, _toComponent.default)(item)];\n  }\n};\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/component/toComponentArray.coffee?");

/***/ }),

/***/ "./src/dc-error.coffee":
/*!*****************************!*\
  !*** ./src/dc-error.coffee ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar DomcomError, dcError, _exports, slice, stackReg, stackReg2, stacktraceMessage;\n\nslice = [].slice;\nstackReg = /at\\s+(.*)\\s+\\((.*):(\\d*):(\\d*)\\)/gi;\nstackReg2 = /at\\s+()(.*):(\\d*):(\\d*)/gi; //export default\n\nmodule.exports = _exports = {};\n\nstacktraceMessage = function stacktraceMessage(message) {\n  var stackIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var error, file, itemInfo, line, method, pos, stackItem, stacklist, stacklistLength;\n\n  if (message) {\n    if (!dcError.prodution) {\n      console.log(message);\n    }\n\n    message += ':\\n';\n  } else {\n    message = \"\";\n  }\n\n  error = new Error();\n\n  if (!dcError.prodution) {\n    console.log(error);\n  }\n\n  stacklist = error.stack.split('\\n').slice(3);\n  stackIndex = 1;\n  stacklistLength = stacklist.length;\n\n  while (stackIndex < stacklistLength) {\n    stackItem = stacklist[stackIndex];\n    itemInfo = stackReg.exec(stackItem) || stackReg2.exec(stackItem);\n\n    if (itemInfo && itemInfo.length === 5) {\n      method = itemInfo[1];\n      file = itemInfo[2];\n      line = itemInfo[3];\n      pos = itemInfo[4];\n      message += file + ':' + line + ':' + pos + ':' + method + '\\n';\n    }\n\n    stackIndex++;\n  }\n\n  return message;\n};\n\n_exports.DomcomError = DomcomError =\n/*#__PURE__*/\nfunction (_Error) {\n  _inherits(DomcomError, _Error);\n\n  function DomcomError(message1, component1) {\n    var _this;\n\n    _classCallCheck(this, DomcomError);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DomcomError).call(this));\n    _this.message = message1;\n    _this.component = component1;\n    return _this;\n  }\n\n  _createClass(DomcomError, [{\n    key: \"toString\",\n    value: function toString() {\n      if (this.component) {\n        return this.component.toString() + '\\n' + this.message;\n      } else {\n        return this.message;\n      }\n    }\n  }]);\n\n  return DomcomError;\n}(_wrapNativeSuper(Error));\n\n_exports.error = dcError = function dcError(message, component) {\n  message = stacktraceMessage(message, 2);\n  throw new DomcomError(message, component);\n};\n\n_exports.onerror = function (message, component) {\n  if (message instanceof DomcomError) {\n    console.log(message);\n    throw new Error(message.message);\n  } else if (message instanceof Error) {\n    throw message;\n  } else {\n    if (component) {\n      console.log(component);\n      console.log(message);\n    } else {\n      console.log(message);\n    }\n\n    throw new Error(message + ':\\n' + stacktraceMessage());\n  }\n};\n\nvar _default = _exports;\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/dc-error.coffee?");

/***/ }),

/***/ "./src/dc-event.coffee":
/*!*****************************!*\
  !*** ./src/dc-event.coffee ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("//# dc框架事件处理\n//#已经移到Emitter.coffee, 以基类方式实现更好。\n\n\n//# sourceURL=webpack:///./src/dc-event.coffee?");

/***/ }),

/***/ "./src/dc-render.coffee":
/*!******************************!*\
  !*** ./src/dc-render.coffee ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _dcUtil = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nvar _isComponent = _interopRequireDefault(__webpack_require__(/*! ./component/isComponent */ \"./src/component/isComponent.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar i, lastTime, len, _rafRender, ref, renderWhenComponentEvent, vendor;\n\nif (typeof window !== 'undefined') {\n  if (!window.requestAnimationFrame) {\n    ref = ['webkit', 'ms', 'moz', 'o'];\n\n    for (i = 0, len = ref.length; i < len; i++) {\n      vendor = ref[i];\n\n      if (window.requestAnimationFrame = window[vendor + 'RequestAnimationFrame']) {\n        window.cancelAnimationFrame = window[vendor + 'CancelAnimationFrame'] || window[vendor + 'CancelRequestAnimationFrame'];\n        break;\n      }\n    }\n  }\n\n  if (!window.requestAnimationFrame) {\n    lastTime = 0;\n\n    window.requestAnimationFrame = function (callback) {\n      var currTime, id, timeToCall;\n      currTime = new Date().getTime();\n      timeToCall = Math.max(0, 16 - (currTime - lastTime));\n      id = window.setTimeout(function () {\n        callback(currTime + timeToCall);\n      }, timeToCall);\n      lastTime = currTime + timeToCall;\n      return id;\n    };\n  }\n\n  if (!window.cancelAnimationFrame) {\n    window.cancelAnimationFrame = function (id) {\n      clearTimeout(id);\n    };\n  }\n}\n\ndc.reset = function () {\n  dc.renderBySystemLoop = false;\n  dc.listeners = {};\n  dc.rootComponentMap = {};\n  return dc.removingChildren = {};\n};\n\ndc.reset();\n\ndc.render = function (force) {\n  var component, dcid, rootComponentMap;\n\n  if (force || dc.alwaysRender || !dc.renderBySystemLoop) {\n    dc.emit('willRender');\n\n    if (!dc.valid) {\n      dc.valid = true;\n      rootComponentMap = dc.rootComponentMap;\n      dc.rootComponentMap = {};\n\n      for (dcid in rootComponentMap) {\n        component = rootComponentMap[dcid];\n        component.render(true);\n      }\n\n      dc.clean();\n    }\n\n    return dc.emit('didRender');\n  }\n};\n\ndc.rafRender = _rafRender = function rafRender() {\n  dc.renderBySystemLoop = true;\n  requestAnimFrame(_rafRender);\n  dc.render(true);\n}; // dc.renderWhen component, events, options\n// dc.renderWhen setInterval, interval, {clear: -> clearInterval test}\n// dc.renderWhen setTimeout, interval\n\n\ndc.renderWhen = function (cause, events, options) {\n  var callback, clear, comp, components, event, handler, j, k, len1, len2, test;\n  components = options.target;\n\n  if (typeof events === 'string') {\n    events = events.split(/\\s+/);\n  }\n\n  if ((0, _isComponent.default)(cause)) {\n    cause = [cause];\n  }\n\n  if (cause instanceof Array) {\n    for (j = 0, len1 = cause.length; j < len1; j++) {\n      comp = cause[j];\n\n      for (k = 0, len2 = events.length; k < len2; k++) {\n        event = events[k];\n        renderWhenComponentEvent(comp, event, components);\n      }\n    }\n  } else if (cause === window.setInterval) {\n    test = options.test;\n    clear = options.clear;\n    handler = null;\n\n    callback = function callback() {\n      var component, l, len3;\n\n      if (!test || test()) {\n        for (l = 0, len3 = components.length; l < len3; l++) {\n          component = components[l];\n          component.render();\n        }\n\n        dc.clean();\n      }\n\n      if (clear && clear()) {\n        return clearInterval(handler);\n      }\n    };\n\n    handler = setInterval(callback, events || 16);\n  } else if (cause === setTimeout) {\n    callback = function callback() {\n      var component, l, len3;\n\n      for (l = 0, len3 = components.length; l < len3; l++) {\n        component = components[l];\n        component.render();\n      }\n\n      return dc.clean();\n    };\n\n    setTimeout(callback, events);\n  }\n};\n\nrenderWhenComponentEvent = function renderWhenComponentEvent(component, event, components) {\n  var componentMap, j, len1;\n\n  if (event.slice(0, 2) !== 'on') {\n    event = 'on' + event;\n  }\n\n  componentMap = component.eventUpdateConfig[event] || (component.eventUpdateConfig[event] = {});\n\n  for (j = 0, len1 = components.length; j < len1; j++) {\n    component = components[j];\n    componentMap[component.dcid] = component;\n  }\n};\n\ndc.stopRenderWhen = function (component, event, components) {\n  var componentMap, dcid;\n\n  if (event.slice(0, 2) !== 'on') {\n    event = 'on' + event;\n  }\n\n  if (components) {\n    if (componentMap = component.eventUpdateConfig[event]) {\n      for (dcid in components) {\n        component = components[dcid];\n        delete componentMap[dcid];\n      }\n    }\n  } else {\n    delete component.eventUpdateConfig[event];\n  }\n};\n\ndc.invalidate = function () {\n  return dc.valid = false;\n};\n\ndc.invalidateContent = function (component) {\n  dc.valid = false;\n  dc.rootComponentMap[component.dcid] = component;\n};\n\ndc.invalidateAttach = function (child) {};\n\ndc.propagateChildNextNode = function (child, nextNode) {};\n\ndc.linkNextNode = function (child, oldNode, nextNode) {};\n\ndc.removingChildren = {};\n\ndc.clean = function () {\n  var _, component, ref1;\n\n  ref1 = dc.removingChildren;\n\n  for (_ in ref1) {\n    component = ref1[_];\n    component.removeDom();\n  }\n\n  dc.removingChildren = {};\n};\n\n//# sourceURL=webpack:///./src/dc-render.coffee?");

/***/ }),

/***/ "./src/dc.coffee":
/*!***********************!*\
  !*** ./src/dc.coffee ***!
  \***********************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _DomNode = _interopRequireDefault(__webpack_require__(/*! ./DomNode */ \"./src/DomNode.coffee\"));\n\nvar _domUtil = __webpack_require__(/*! ./dom-util */ \"./src/dom-util.coffee\");\n\nvar _Component = _interopRequireDefault(__webpack_require__(/*! ./component/Component */ \"./src/component/Component.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar dc;\n\n/*\n * a utility to do almost everything\n * generate Component instance\n * as the dc framework namespace\n * hold convinent getter, setter and method, etc...\n * @params template: the template for the component\n * @params model: the model for the component data\n * model can be the real value of data\n * can be a functioin to generate the data\n * can also be an instance of class Model\n */\nvar _default = module.exports = dc = function dc(template, model) {\n  var comp;\n  comp = new _Component.default(template, model);\n  return comp;\n};\n/*\n * 创建部件并设置其数据模型\n */\n\n\nexports.default = _default;\n\ndc.data = function (model) {\n  var comp;\n  comp = dc();\n  comp.model = model; // 方便链式语法\n\n  return comp;\n};\n/*\n * 创建部件并设置其模版\n */\n\n\ndc.shape = function (shape) {\n  var comp;\n  comp = dc();\n  comp.template = template; // 方便链式语法\n\n  return comp;\n};\n/* 选择dc运行和编译时基于的后端，需要预先注册\n * 用扩展机制、插件机制来考虑相关的实现\n */\n\n\ndc.use = function (backend) {\n  // todo 如果backend为字符串，则查找对应的后端插件部件\n  return dc._backend = backend;\n};\n/* 选择dc运行和编译时基于的后端，需要预先注册\n * 用扩展机制、插件机制来考虑相关的实现\n */\n\n\ndc.backend = function (backendPlugin) {\n  dc.backends[backendPlugin.name] = backendPlugin;\n};\n\n//# sourceURL=webpack:///./src/dc.coffee?");

/***/ }),

/***/ "./src/directive/bind.coffee":
/*!***********************************!*\
  !*** ./src/directive/bind.coffee ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _domUtil = __webpack_require__(/*! ../dom-util */ \"./src/dom-util.coffee\");\n\nvar _default = module.exports = function (binding) {\n  return function (comp) {\n    comp.setProp((0, _domUtil.getBindProp)(comp), binding, comp.props, 'Props');\n    return comp;\n  };\n};\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/directive/bind.coffee?");

/***/ }),

/***/ "./src/directive/index.coffee":
/*!************************************!*\
  !*** ./src/directive/index.coffee ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _model = _interopRequireDefault(__webpack_require__(/*! ./model */ \"./src/directive/model.coffee\"));\n\nvar _bind = _interopRequireDefault(__webpack_require__(/*! ./bind */ \"./src/directive/bind.coffee\"));\n\nvar _showHide = __webpack_require__(/*! ./show-hide */ \"./src/directive/show-hide.coffee\");\n\nvar _options = _interopRequireDefault(__webpack_require__(/*! ./options */ \"./src/directive/options.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nmodule.exports = {\n  $model: _model.default,\n  $bind: _bind.default,\n  $show: _showHide.$show,\n  $hide: _showHide.$hide,\n  $options: _options.default\n};\nvar _default = module.exports;\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/directive/index.coffee?");

/***/ }),

/***/ "./src/directive/model.coffee":
/*!************************************!*\
  !*** ./src/directive/model.coffee ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _domUtil = __webpack_require__(/*! ../dom-util */ \"./src/dom-util.coffee\");\n\nvar _default = module.exports = function (binding, eventName) {\n  return function (comp) {\n    var bindProp, props;\n    props = comp.props;\n    bindProp = (0, _domUtil.getBindProp)(comp);\n    comp.setProp(bindProp, binding, props, 'Props');\n    comp.bind(eventName || 'onchange', function (event, node) {\n      return binding(node[bindProp]);\n    }, 'before');\n    return comp;\n  };\n};\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/directive/model.coffee?");

/***/ }),

/***/ "./src/directive/options.coffee":
/*!**************************************!*\
  !*** ./src/directive/options.coffee ***!
  \**************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _instantiate = __webpack_require__(/*! ../instantiate */ \"./src/instantiate.coffee\");\n\nvar _tag = __webpack_require__(/*! ../tag */ \"./src/tag.coffee\");\n\nvar _Tag = _interopRequireDefault(__webpack_require__(/*! ../component/Tag */ \"./src/component/Tag.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n// options directive，used for select tag\nvar _default = module.exports = function (items, attrs) {\n  return function (comp) {\n    var i, item, len, options;\n\n    if (!(comp instanceof _Tag.default) || comp.tagName !== 'select') {\n      throw new Error('options should be only used in select tag');\n    }\n\n    options = [];\n\n    if (items) {\n      for (i = 0, len = items.length; i < len; i++) {\n        item = items[i];\n        options.push((0, _tag.option)(attrs, [(0, _instantiate.txt)(item)]));\n      }\n    }\n\n    return comp.setChildren(0, options);\n  };\n};\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/directive/options.coffee?");

/***/ }),

/***/ "./src/directive/show-hide.coffee":
/*!****************************************!*\
  !*** ./src/directive/show-hide.coffee ***!
  \****************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n//export default\n\n/* @param test - paramenter expression for directive\n*/\nvar _exports, showHide;\n\n_exports = {};\n\nshowHide = function showHide(showing) {\n  return function (test, display) {\n    return function (comp) {\n      comp.showHide(showing, test, display);\n      return comp;\n    };\n  };\n};\n\n_exports.$show = showHide(true);\n_exports.$hide = showHide(false);\n\nvar _default = module.exports = _exports;\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/directive/show-hide.coffee?");

/***/ }),

/***/ "./src/dom-util.coffee":
/*!*****************************!*\
  !*** ./src/dom-util.coffee ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lazyFlow = __webpack_require__(/*! lazy-flow */ \"./packages/lazy-flow/index.js\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar _exports;\n\n//export default\nmodule.exports = _exports = {};\n\nif (typeof window !== 'undefined') {\n  _exports.normalizeDomElement = function (domElement) {\n    if (typeof domElement === 'string') {\n      domElement = document.querySelector(domElement);\n    }\n\n    return domElement;\n  };\n}\n\n_exports.getBindProp = function (component) {\n  var tagName;\n  tagName = component.tagName;\n\n  if (!tagName) {\n    throw new Error('trying to bind a Component which is not a Tag');\n  } else if (tagName === 'input' && component.props.type === 'checkbox') {\n    return 'checked';\n  } else {\n    return 'value';\n  }\n};\n\nif (typeof window !== 'undefined') {\n  // add browser compatability for addEventListener and removeEventListener in ie 6, 7, 8\n  if (document.addEventListener) {\n    _exports.addEventListener = function (node, name, handler, useCapture) {\n      node.addEventListener(name, handler, useCapture);\n    };\n\n    _exports.removeEventListener = function (node, name, handler) {\n      node.removeEventListener(name, handler);\n    };\n  } else {\n    _exports.addEventListener = function (node, name, handler) {\n      node.attachEvent(name, handler);\n    };\n\n    _exports.removeEventListener = function (node, name, handler) {\n      node.detachEvent(name, handler);\n    };\n  }\n} // Returns true if it is a DOM element\n\n\n_exports.isElement = function (item) {\n  if ((typeof HTMLElement === \"undefined\" ? \"undefined\" : _typeof(HTMLElement)) === \"object\") {\n    return item instanceof HTMLElement;\n  } else {\n    return item && _typeof(item) === \"object\" && item !== null && item.nodeType === 1 && typeof item.nodeName === \"string\";\n  }\n};\n\n_exports.domField = function (value, component) {\n  var fn;\n\n  if (value == null) {\n    return '';\n  } else if (typeof value !== 'function') {\n    if (value.then && value.catch) {\n      fn = react(function () {\n        return fn.promiseResult;\n      });\n      value.then(function (result) {\n        fn.promiseResult = result;\n        return fn.invalidate();\n      }).catch(function (error) {\n        fn.promiseResult = error;\n        return fn.invalidate();\n      });\n      return fn;\n    } else {\n      return value;\n    }\n  } else if (value.bindComponent) {\n    return value.bindComponent(component);\n  } else if (!value.invalidate) {\n    return (0, _lazyFlow.renew)(value);\n  } else {\n    return value;\n  }\n};\n\n_exports.domValue = function (value, component) {\n  if (value == null) {\n    return '';\n  } else if (typeof value !== 'function') {\n    return value;\n  } else {\n    value = value.call(component);\n\n    if (value == null) {\n      return '';\n    } else {\n      return value;\n    }\n  }\n}; // family do not consider exceeding TranBlock\n// a BaseBlock can have only one reference of one component in all of its family\n// it's the responsiblility of the user program of domcom to keep no conflicting reference while exceeding TranBlock\n\n\n_exports.extendChildFamily = function (family, child) {\n  var dcid;\n\n  for (dcid in child.family) {\n    if (family[dcid]) {\n      throw new Error('do not allow to have the same component to be referenced in different location of one List');\n    }\n\n    family[dcid] = true;\n  }\n};\n\nvar _default = _exports;\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/dom-util.coffee?");

/***/ }),

/***/ "./src/domcom.coffee":
/*!***************************!*\
  !*** ./src/domcom.coffee ***!
  \***************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _dc = _interopRequireDefault(__webpack_require__(/*! ./dc */ \"./src/dc.coffee\"));\n\nvar _property = _interopRequireDefault(__webpack_require__(/*! ./property */ \"./src/property/index.coffee\"));\n\nvar _index = _interopRequireDefault(__webpack_require__(/*! ./directive/index */ \"./src/directive/index.coffee\"));\n\nvar _backend = _interopRequireDefault(__webpack_require__(/*! ./backend */ \"./src/backend/index.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nif (typeof window !== 'undefined') {\n  window.dc = _dc.default;\n} // dc.DomNode from './DomNode'\n\n\n_dc.default.EventMixin = __webpack_require__(/*! ./dc-event */ \"./src/dc-event.coffee\");\n// components\nObject.assign(_dc.default, _backend.default, __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\"), __webpack_require__(/*! ./dom-util */ \"./src/dom-util.coffee\"), __webpack_require__(/*! ./dc-render */ \"./src/dc-render.coffee\"), __webpack_require__(/*! ./component */ \"./src/component/index.coffee\"), __webpack_require__(/*! ./backend */ \"./src/backend/index.coffee\"), __webpack_require__(/*! ./instantiate */ \"./src/instantiate.coffee\"), __webpack_require__(/*! ./dc-error */ \"./src/dc-error.coffee\"));\ndebugger;\n_dc.default.property = _property.default;\n_dc.default.builtinDirective = _index.default;\nObject.assign(_dc.default, _dc.default.property, _dc.default.builtinDirective);\n\nvar _default = module.exports = _dc.default;\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/domcom.coffee?");

/***/ }),

/***/ "./src/instantiate.coffee":
/*!********************************!*\
  !*** ./src/instantiate.coffee ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _dcUtil = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nvar _lazyFlow = __webpack_require__(/*! lazy-flow */ \"./packages/lazy-flow/index.js\");\n\nfunction _toArray(arr) { return _arrayWithHoles(arr) || _iterableToArray(arr) || _nonIterableRest(); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar Case,\n    Comment,\n    Component,\n    Defer,\n    Func,\n    Html,\n    If,\n    List,\n    MVC,\n    Nothing,\n    Pick,\n    Tag,\n    Text,\n    attrsChildren,\n    _exports,\n    isAttrs,\n    isComponent,\n    list,\n    tag,\n    toBlock,\n    _toTagChildren,\n    splice = [].splice;\n\nvar _require = __webpack_require__(/*! ./component */ \"./src/component/index.coffee\");\n\nComponent = _require.Component;\ntoBlock = _require.toBlock;\nisComponent = _require.isComponent;\nTag = _require.Tag;\nText = _require.Text;\nComment = _require.Comment;\nHtml = _require.Html;\nIf = _require.If;\nCase = _require.Case;\nFunc = _require.Func;\nList = _require.List;\nPick = _require.Pick;\nNothing = _require.Nothing;\nDefer = _require.Defer;\nMVC = _require.MVC;\n//export default\nmodule.exports = _exports = {};\n\n_exports.isAttrs = isAttrs = function isAttrs(item) {\n  return _typeof(item) === 'object' && item !== null && !isComponent(item) && !(item instanceof Array);\n};\n\ndebugger;\n\nattrsChildren = function attrsChildren(args) {\n  var attrs;\n  attrs = args[0];\n\n  if (!args.length) {\n    return [{}, []];\n  } else if (attrs == null) {\n    return [{}, args.slice(1)];\n  } else if (attrs instanceof Array) {\n    return [{}, args];\n  } else if (typeof attrs === 'function') {\n    return [{}, args];\n  } else if (_typeof(attrs) === 'object') {\n    if (isComponent(attrs)) {\n      return [{}, args];\n    } else {\n      return [attrs, args.slice(1)];\n    }\n  } else {\n    return [{}, args];\n  }\n};\n\n_toTagChildren = function toTagChildren(args) {\n  if (!(args instanceof Array)) {\n    return [args];\n  } else if (!args.length) {\n    return [];\n  } else if (args.length === 1) {\n    return _toTagChildren(args[0]);\n  } else {\n    return args;\n  }\n};\n\n_exports.tag = tag = function tag(tagName) {\n  var attrs, children;\n\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  var _attrsChildren = attrsChildren(args);\n\n  var _attrsChildren2 = _slicedToArray(_attrsChildren, 2);\n\n  attrs = _attrsChildren2[0];\n  children = _attrsChildren2[1];\n  return new Tag(tagName, attrs, _toTagChildren(children));\n};\n\n_exports.nstag = function (tagName, namespace) {\n  var attrs, children;\n\n  for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n    args[_key2 - 2] = arguments[_key2];\n  }\n\n  var _attrsChildren3 = attrsChildren(args);\n\n  var _attrsChildren4 = _slicedToArray(_attrsChildren3, 2);\n\n  attrs = _attrsChildren4[0];\n  children = _attrsChildren4[1];\n  return new Tag(tagName, attrs, _toTagChildren(children), namespace);\n};\n\n_exports.txt = function (attrs, text) {\n  if (isAttrs(attrs)) {\n    return new Tag(null, attrs, [new Text(text)]);\n  } else {\n    return new Text(attrs);\n  }\n};\n\n_exports.comment = function (attrs, text) {\n  if (isAttrs(attrs)) {\n    return new Tag(null, attrs, [new Comment(text)]);\n  } else {\n    return new Comment(attrs);\n  }\n};\n\n_exports.cdata = function (attrs, text) {\n  if (isAttrs(attrs)) {\n    return new Tag(null, attrs, [new Cdata(text)]);\n  } else {\n    return new Cdata(attrs);\n  }\n}; // this is for Html Component, which takes some text as innerHTML\n// for <html> ... </html>, please use tagHtml instead\n\n\n_exports.html = function (attrs, text, transform) {\n  return new Html(attrs, text, transform);\n};\n\n_exports.if_ = function (attrs, test, then_, else_, merge, recursive) {\n  if (isAttrs(attrs)) {\n    return new Tag(null, attrs, [new If(test, then_, else_, merge, recursive)]);\n  } else {\n    return new If(attrs, test, then_, merge, recursive);\n  }\n};\n\n_exports.forceIf = function (attrs, test, then_, else_) {\n  // always should NOT merge forced if\n  if (isAttrs(attrs)) {\n    return new Tag(null, attrs, [new If(test, then_, else_, true, false, true)]);\n  } else {\n    return new If(attrs, test, then_, true, false, true);\n  }\n};\n\n_exports.mergeIf = function (attrs, test, then_, else_, recursive) {\n  if (isAttrs(attrs)) {\n    return new Tag(null, attrs, [new If(test, then_, else_, true, recursive)]);\n  } else {\n    return new If(attrs, test, then_, true, recursive);\n  }\n};\n\n_exports.recursiveIf = function (attrs, test, then_, else_) {\n  if (isAttrs(attrs)) {\n    return new Tag(null, attrs, [new If(test, then_, else_, true, true)]);\n  } else {\n    return new If(attrs, test, then_, true, true);\n  }\n};\n\n_exports.case_ = function (attrs, test, map, else_) {\n  if (isAttrs(attrs)) {\n    return new Tag(null, attrs, [new Case(test, map, else_)]);\n  } else {\n    return new Case(attrs, test, map);\n  }\n};\n\n_exports.forceCase = function (attrs, test, map, else_) {\n  if (isAttrs(attrs)) {\n    return new Tag(null, attrs, [new Case(test, map, else_, true)]);\n  } else {\n    return new Case(attrs, test, map, true);\n  }\n};\n\n_exports.cond = function (attrs) {\n  var _ref, _ref2, _splice$call, _splice$call2;\n\n  for (var _len3 = arguments.length, condComponents = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {\n    condComponents[_key3 - 1] = arguments[_key3];\n  }\n\n  var else_, ref;\n  ref = condComponents, (_ref = ref, _ref2 = _toArray(_ref), condComponents = _ref2.slice(0), _ref), (_splice$call = splice.call(condComponents, -1), _splice$call2 = _slicedToArray(_splice$call, 1), else_ = _splice$call2[0], _splice$call);\n\n  if (isAttrs(attrs)) {\n    if (!(0, _dcUtil.isEven)(condComponents)) {\n      condComponents.push(else_);\n      else_ = null;\n    }\n\n    return new Tag(null, attrs, [new Cond(condComponents, else_)]);\n  } else {\n    condComponents.unshift(attrs);\n\n    if (!(0, _dcUtil.isEven)(condComponents)) {\n      condComponents.push(else_);\n      else_ = null;\n    }\n\n    return new Cond(condComponents, else_);\n  }\n};\n\n_exports.func = function (attrs, fn) {\n  if (isAttrs(attrs)) {\n    return new Tag(null, attrs, [new Func(fn)]);\n  } else {\n    return new Func(attrs); // attrs become fn\n  }\n}; // pick can NOT wrapped with attrs\n// because host must be an object!!!\n\n\n_exports.pick = function (host, field, initialContent) {\n  return new Pick(host, field, initialContent);\n};\n\n_exports.list = list = function list(attrs) {\n  for (var _len4 = arguments.length, lst = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n    lst[_key4 - 1] = arguments[_key4];\n  }\n\n  if (isAttrs(attrs)) {\n    return new Tag(null, attrs, [new List(lst)]);\n  } else {\n    lst.unshift(attrs);\n\n    if (lst.length === 1) {\n      return toBlock(lst[0]);\n    } else {\n      return new List(lst);\n    }\n  }\n}; // promise is a Promise instance which have .then and .catch the two method\n// fulfill: (value, promise, component) ->\n// reject: (reason, promise, component) ->\n// init: will be converted to component by toBlock\n\n\n_exports.defer = function (attrs, promise, fulfill, reject, init) {\n  if (isAttrs(attrs)) {\n    return new Tag(null, attrs, [new Defer(promise, fulfill, reject, init)]);\n  } else {\n    return new Defer(attrs, promise, fulfill, reject);\n  }\n};\n\n_exports.mvc = function (view, model) {\n  return new MVC(view, model);\n};\n\nObject.assign(_exports, __webpack_require__(/*! ./tag */ \"./src/tag.coffee\"));\nvar _default = _exports;\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/instantiate.coffee?");

/***/ }),

/***/ "./src/mergeIf.coffee":
/*!****************************!*\
  !*** ./src/mergeIf.coffee ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _Tag = _interopRequireDefault(__webpack_require__(/*! ./component/Tag */ \"./src/component/Tag.coffee\"));\n\nvar _List = _interopRequireDefault(__webpack_require__(/*! ./component/List */ \"./src/component/List.coffee\"));\n\nvar _Nothing = _interopRequireDefault(__webpack_require__(/*! ./component/Nothing */ \"./src/component/Nothing.coffee\"));\n\nvar _events = __webpack_require__(/*! ./property/events */ \"./src/property/events.coffee\");\n\nvar _addon = _interopRequireDefault(__webpack_require__(/*! lazy-flow/addon */ \"./packages/lazy-flow/addon.js\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar emptyEventCallback, _exports, flowIf, mergeIfChild, mergeIfChildren, mergeIfClassFn, mergeIfEvents, mergeIfProps;\n\nflowIf = _addon.default.if_; //export default\n\nmodule.exports = _exports = {}; // do not need toBlock\n// do not need check whether test is a function\n// because mergeIf is called in If component constructor,\n// after then_, else_ was converted to component\n// and check test is a function\n\n_exports.mergeIf = function (test, then_, else_, recursive) {\n  var children, className, component, elseTransform, events, props, style, thenTransform, transform;\n  If(from('./component/If'));\n\n  if (then_ === else_) {\n    return then_;\n  } else if (then_.constructor === _Tag.default && else_.constructor === _Tag.default && then_.tagName === else_.tagName && then_.namespace === else_.namespace) {\n    children = mergeIfChildren(test, then_, else_, recursive);\n    component = new _Tag.default(then_.tagName, {}, children);\n    className = mergeIfClassFn(test, then_.className, else_.className);\n    props = mergeIfProps(test, then_.props, else_.props);\n    style = mergeIfProps(test, then_.style, else_.style);\n    events = mergeIfEvents(test, then_.domEventCallbackMap, else_.domEventCallbackMap);\n    return component.addClass(className).prop(props).css(style).bind(events);\n  } else if (then_.isHtml && else_.isHtml) {\n    thenTransform = then_.transform;\n    elseTransform = else_.transform;\n\n    transform = function transform(text) {\n      if (test()) {\n        return thenTransform && thenTransform(text) || text;\n      } else {\n        return elseTransform && elseTransform(text) || text;\n      }\n    };\n\n    return new then_.constructor(flowIf(test, then_.text, else_.text), transform); // this is for Text, Comment and Cdata\n  } else if (then_.isText && else_.isText && then_.constructor === else_.constructor) {\n    return new then_.constructor(flowIf(test, then_.text, else_.text));\n  } else if (then_ instanceof _Nothing.default && else_ instanceof _Nothing.default) {\n    return then_; // List component\n  } else if (then_.isList && else_.isList) {\n    return new _List.default(mergeIfChildren(test, then_, else_, recursive));\n  } else {\n    return new If(test, then_, else_, false, false, true); // merge, recursive, forceIf\n  }\n};\n\nmergeIfChild = function mergeIfChild(test, then_, else_, recursive) {\n  if (!recursive && (then_.isList || else_.isList)) {\n    // whether another is List or not, then_ and else_ should or could not be merged\n    If(from('./component/If'));\n    return new If(test, then_, else_, false, false, true); // merge, recursive, forceIf\n  } else {\n    return mergeIf(test, then_, else_, recursive);\n  }\n};\n\n_exports.mergeIfChildren = mergeIfChildren = function mergeIfChildren(test, then_, else_, recursive) {\n  var children, elseChildren, elseChildrenLength, elseItem, i, j, k, l, len, len1, len2, thenChildren, thenChildrenLength, thenItem;\n  thenChildren = then_.children;\n  elseChildren = else_.children;\n  thenChildrenLength = thenChildren.length;\n  elseChildrenLength = elseChildren.length;\n\n  if (thenChildrenLength === elseChildrenLength) {\n    children = new Array(thenChildrenLength);\n\n    for (i = j = 0, len = thenChildren.length; j < len; i = ++j) {\n      thenItem = thenChildren[i];\n      children[i] = mergeIfChild(test, thenItem, elseChildren[i], recursive);\n    }\n  } else if (thenChildrenLength < elseChildrenLength) {\n    children = new Array(elseChildrenLength);\n\n    for (i = k = 0, len1 = thenChildren.length; k < len1; i = ++k) {\n      thenItem = thenChildren[i];\n      children[i] = mergeIfChild(test, thenItem, elseChildren[i], recursive);\n    }\n\n    while (i < elseChildrenLength) {\n      children[i] = mergeIf(test, new _Nothing.default(), elseChildren[i]);\n      i++; // if thenChildrenLength > elseChildrenLength\n    }\n  } else {\n    children = new Array(thenChildrenLength);\n\n    for (i = l = 0, len2 = elseChildren.length; l < len2; i = ++l) {\n      elseItem = elseChildren[i];\n      children[i] = mergeIfChild(test, thenChildren[i], elseItem, recursive);\n    }\n\n    while (i < thenChildrenLength) {\n      children[i] = mergeIf(test, thenChildren[i], new _Nothing.default());\n      i++;\n    }\n  }\n\n  return children;\n};\n\nmergeIfClassFn = function mergeIfClassFn(test, thenClassName, elseClassName) {\n  return mergeIfProps(test, thenClassName.classMap, elseClassName.classMap);\n};\n\nmergeIfProps = function mergeIfProps(test, thenProps, elseProps) {\n  var prop, unified;\n  unified = Object.assign({}, thenProps, elseProps);\n\n  for (prop in unified) {\n    unified[prop] = flowIf(test, thenProps[prop], elseProps[prop]);\n  }\n\n  return unified;\n};\n\nemptyEventCallback = function emptyEventCallback() {};\n\nmergeIfEvents = function mergeIfEvents(test, thenEventCallbackMap, elseEventCallbackMap) {\n  var elseCallbackList, elseHandler, eventName, thenCallbackList, thenHandler, unified;\n  unified = Object.assign({}, thenEventCallbackMap, elseEventCallbackMap);\n\n  for (eventName in unified) {\n    if (thenCallbackList = thenEventCallbackMap[eventName]) {\n      thenHandler = (0, _events.domEventHandlerFromArray)(thenCallbackList.slice(0));\n    } else {\n      thenHandler = emptyEventCallback;\n    }\n\n    if (elseCallbackList = elseEventCallbackMap[eventName]) {\n      elseHandler = (0, _events.domEventHandlerFromArray)(elseCallbackList.slice(0));\n    } else {\n      elseHandler = emptyEventCallback;\n    }\n\n    unified[eventName] = function (event) {\n      if (test()) {\n        return thenHandler.call(this, event);\n      } else {\n        return elseHandler.call(this, event);\n      }\n    };\n  }\n\n  return unified;\n};\n\nvar _default = _exports;\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/mergeIf.coffee?");

/***/ }),

/***/ "./src/property/attrs.coffee":
/*!***********************************!*\
  !*** ./src/property/attrs.coffee ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _isComponent = __webpack_require__(/*! ../component/isComponent */ \"./src/component/isComponent.coffee\");\n\nvar _events = __webpack_require__(/*! ./events */ \"./src/property/events.coffee\");\n\nvar _classFn = _interopRequireDefault(__webpack_require__(/*! ./classFn */ \"./src/property/classFn.coffee\"));\n\nvar _style = __webpack_require__(/*! ./style */ \"./src/property/style.coffee\");\n\nvar _domUtil = __webpack_require__(/*! ../dom-util */ \"./src/dom-util.coffee\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar attrPropNameMap, _exports;\n\n//export default\nmodule.exports = _exports = {};\n\n_exports.extendAttrs = function (attrs, obj) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var key, objClass, style, value;\n\n  if (!obj) {\n    return attrs;\n  } else if (!attrs) {\n    return obj;\n  }\n\n  objClass = (0, _classFn.default)([obj.class, obj.className]);\n\n  if (options.replaceClass) {\n    attrs.className = objClass;\n  } else {\n    attrs.className = (0, _classFn.default)([attrs.class, attrs.className]);\n    delete attrs.class;\n    attrs.className = (0, _classFn.default)([attrs.className, objClass]);\n  }\n\n  style = (0, _style.styleFrom)(attrs.style);\n\n  if (obj.style) {\n    attrs.style = Object.assign(style, obj.style);\n  } else {\n    attrs.style = style;\n  }\n\n  for (key in obj) {\n    value = obj[key];\n\n    if (key === 'class' || key === 'className') {\n      // class and className have been processed in advance\n      continue;\n    } else if (key.slice(0, 2) === 'on') {\n      if (options['replace_' + key] || options.replaceEvents) {\n        attrs[key] = value;\n      } else {\n        (0, _events.extendEventValue)(attrs, key, value);\n      }\n    } else if (key === 'style') {\n      continue;\n    } else {\n      attrs[key] = value;\n    }\n  }\n\n  return attrs;\n};\n\nattrPropNameMap = {\n  'for': 'htmlFor'\n};\n\n_exports.attrToPropName = function (name) {\n  var i, len, newName, pieces;\n\n  if (newName = attrPropNameMap[name]) {\n    return newName;\n  } else {\n    pieces = name.split('-');\n\n    if (pieces.length === 1) {\n      return name;\n    } else {\n      i = 1;\n      len = pieces.length;\n\n      while (i < len) {\n        pieces[i] = pieces[i][0].toUpperCase() + pieces[i].slice(1);\n        i++;\n      }\n\n      return pieces.join('');\n    }\n  }\n};\n\n_exports.setText = function (text) {\n  var me;\n  text = (0, _domUtil.domField)(text, this);\n\n  if (this._text === text) {\n    return this;\n  }\n\n  this._text = text;\n  me = this;\n\n  if (typeof text === 'function') {\n    text.onInvalidate(function () {\n      return me.invalidate();\n    });\n  }\n\n  this.invalidate();\n  return this;\n};\n\nvar _default = _exports;\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/property/attrs.coffee?");

/***/ }),

/***/ "./src/property/classFn.coffee":
/*!*************************************!*\
  !*** ./src/property/classFn.coffee ***!
  \*************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _lazyFlow = __webpack_require__(/*! lazy-flow */ \"./packages/lazy-flow/index.js\");\n\nvar _domUtil = __webpack_require__(/*! ../dom-util */ \"./src/dom-util.coffee\");\n\nvar _dcUtil = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar _classFn;\n\nvar _default = module.exports = _classFn = function classFn() {\n  for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n    items[_key] = arguments[_key];\n  }\n\n  var classMap, _extendClassMap, _method, processClassValue;\n\n  classMap = {};\n\n  _method = function method() {\n    var klass, lst, value;\n\n    if (!arguments.length) {\n      lst = [];\n      _method.valid = true;\n\n      for (klass in classMap) {\n        value = classMap[klass];\n\n        if (typeof value === 'function') {\n          value = value.call(this);\n        }\n\n        if (value) {\n          lst.push(klass);\n        }\n      }\n\n      return lst.join(' ');\n    } else {\n      _extendClassMap([].slice(arguments));\n    }\n  };\n\n  processClassValue = function processClassValue(name, value) {\n    var oldValue;\n    oldValue = classMap[name];\n\n    if (typeof oldValue === 'function') {\n      oldValue.offInvalidate(_method.invalidate);\n    }\n\n    if (oldValue !== value) {\n      // value is a function or true\n      _method.invalidate();\n\n      if (typeof value === 'function' && value.onInvalidate) {\n        value.onInvalidate(_method.invalidate);\n      }\n    }\n\n    if (value) {\n      return classMap[name] = value;\n    } else {\n      return delete classMap[name];\n    }\n  };\n\n  _extendClassMap = function extendClassMap(items) {\n    var i, item, j, len, len1, name, names, ref, value;\n\n    if (!items) {\n      return;\n    }\n\n    if (!(0, _dcUtil.isArray)(items)) {\n      items = [items];\n    }\n\n    for (i = 0, len = items.length; i < len; i++) {\n      item = items[i];\n\n      if (!item) {\n        continue;\n      }\n\n      if (typeof item === 'string') {\n        names = item.trim().split(/\\s+(?:,\\s+)?/);\n\n        for (j = 0, len1 = names.length; j < len1; j++) {\n          name = names[j];\n\n          if (name[0] === '!') {\n            processClassValue(name.slice(1), false);\n          } else {\n            processClassValue(name, true);\n          }\n        }\n      } else if (item instanceof Array) {\n        _extendClassMap(item);\n      } else if (item && item.classMap) {\n        ref = item.classMap; // another classFn\n\n        for (name in ref) {\n          value = ref[name];\n          processClassValue(name, value);\n        }\n      } else if (_typeof(item) === 'object') {\n        for (name in item) {\n          value = item[name];\n          processClassValue(name, value);\n        }\n      }\n    }\n  };\n\n  (0, _lazyFlow.react)(_method);\n\n  _extendClassMap(items);\n\n  _method.classMap = classMap;\n  _method.valid = !Object.keys(classMap).length;\n\n  _method.removeClass = function () {\n    var i, item, len, results;\n    results = [];\n\n    for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      items[_key2] = arguments[_key2];\n    }\n\n    for (i = 0, len = items.length; i < len; i++) {\n      item = items[i];\n      results.push(processClassValue(item, false));\n    }\n\n    return results;\n  };\n\n  _method.extend = function () {\n    for (var _len3 = arguments.length, items = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      items[_key3] = arguments[_key3];\n    }\n\n    return _extendClassMap(items);\n  };\n\n  _method.clone = function () {\n    var newClassName;\n    newClassName = _classFn();\n    return newClassName.extend(_method);\n  };\n\n  return _method;\n};\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/property/classFn.coffee?");

/***/ }),

/***/ "./src/property/css-arith.coffee":
/*!***************************************!*\
  !*** ./src/property/css-arith.coffee ***!
  \***************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _Tag = _interopRequireDefault(__webpack_require__(/*! ../component/Tag */ \"./src/component/Tag.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _exports, reNonUnit, unitAdd, unitDiv, unitMul, unitSub;\n\n//export default\nmodule.exports = _exports = {};\nreNonUnit = /[\\d\\s\\.-]/g;\n\n_exports.unitAdd = unitAdd = function unitAdd(x, y) {\n  var num;\n  num = parseFloat(x);\n\n  if (isNaN(num)) {\n    console.log('wrong type in unitAdd(prop, value)');\n  }\n\n  return num + parseFloat(y) + x.replace(reNonUnit, '');\n};\n\n_exports.unitSub = unitSub = function unitSub(x, y) {\n  var num;\n  num = parseFloat(x);\n\n  if (isNaN(num)) {\n    console.log('wrong type in unitSub(prop, value)');\n  }\n\n  return num - parseFloat(y) + x.replace(reNonUnit, '');\n};\n\n_exports.unitMul = unitMul = function unitMul(x, y) {\n  var num;\n  num = parseFloat(x);\n\n  if (isNaN(num)) {\n    console.log('wrong type in unitMul(prop, value)');\n  }\n\n  return num * parseFloat(y) + x.replace(reNonUnit, '');\n};\n\n_exports.unitDiv = unitDiv = function unitDiv(x, y) {\n  var num;\n  num = parseFloat(x);\n\n  if (isNaN(num)) {\n    console.log('wrong type in unitDiv(prop, value)');\n  }\n\n  return num / parseFloat(y) + x.replace(reNonUnit, '');\n};\n\n_Tag.default.prototype.cssAdd = function (prop, value) {\n  var v;\n  v = unitAdd(this.css(prop), value);\n  return this.css(prop, v);\n};\n\n_Tag.default.prototype.cssSub = function (prop, value) {\n  return this.css(prop, unitSub(this.css(prop), value));\n};\n\n_Tag.default.prototype.cssMul = function (prop, value) {\n  return this.css(prop, unitMul(this.css(prop), value));\n};\n\n_Tag.default.prototype.cssDiv = function (prop, value) {\n  return this.css(prop, unitDiv(this.css(prop), value));\n};\n\nvar _default = _exports;\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/property/css-arith.coffee?");

/***/ }),

/***/ "./src/property/delegate-event.coffee":
/*!********************************************!*\
  !*** ./src/property/delegate-event.coffee ***!
  \********************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nvar _Tag = _interopRequireDefault(__webpack_require__(/*! ../component/Tag */ \"./src/component/Tag.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar delegateToComponentHandler, delegateToHolderHandler, delegateToMethodHandler;\n\n// delegate to component.prefix_XXX method\ndelegateToMethodHandler = function delegateToMethodHandler() {\n  var prefix = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'do_';\n  return function (event) {\n    var targetComponent, targetNode;\n    targetNode = event.target;\n    targetComponent = targetNode.component;\n    return targetComponent[prefix + event.type](event);\n  };\n}; // delegate until holder...holder.do_XXX method\n\n\ndelegateToHolderHandler = function delegateToHolderHandler(prefix) {\n  return function (event) {\n    var handler, method, targetComponent, targetNode;\n    targetNode = event.target;\n    targetComponent = targetNode.component;\n    method = prefix + event.type;\n\n    while (targetComponent) {\n      handler = targetComponent[method];\n\n      if (handler) {\n        handler.call(targetComponent, event);\n\n        if (event.continueDelegating) {\n          targetComponent = targetComponent.holder;\n        } else {\n          break;\n        }\n      } else {\n        targetComponent = targetComponent.holder;\n      }\n    }\n  };\n}; // delegate to the given component.prefix_XXX method\n\n\ndelegateToComponentHandler = function delegateToComponentHandler(component, prefix) {\n  return function (event) {\n    var handler;\n\n    if (handler = component[prefix + event.type]) {\n      handler.call(component, event);\n    }\n  };\n}; // delegate to component.prefix_XXX method\n\n\n_Tag.default.prototype.delegate = function (events, delegationHandler) {\n  if (typeof delegationHandler !== 'function') {\n    delegationHandler = delegateToMethodHandler(delegationHandler);\n  }\n\n  return this.bind(events, delegationHandler);\n}; // delegate until holder...holder.prefix_XXX method\n\n\n_Tag.default.prototype.delegateToHolder = function (events) {\n  var prefix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'do_';\n  var delegationHandler;\n  delegationHandler = delegateToHolderHandler(prefix);\n  return this.bind(events, delegationHandler);\n}; // delegate to the given component.prefix_XXX method\n\n\n_Tag.default.prototype.delegateToComponent = function (events, component) {\n  var prefix = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 'do_';\n  var delegationHandler;\n  delegationHandler = delegateToComponentHandler(component, prefix);\n  return this.bind(events, delegationHandler);\n};\n\n//# sourceURL=webpack:///./src/property/delegate-event.coffee?");

/***/ }),

/***/ "./src/property/events.coffee":
/*!************************************!*\
  !*** ./src/property/events.coffee ***!
  \************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\n//export default\nvar addEventListenerMap, eventName, _exports, extendEventValue, i, len, ref;\n\nmodule.exports = _exports = {};\n\n_exports.domEventHandler = function (event) {\n  var _, comp, component, componentMap, domEventCallbacks, eventType, fn, i, len, result;\n\n  if (component = this.component) {\n    eventType = 'on' + event.type;\n    domEventCallbacks = component.domEventCallbackMap[eventType];\n\n    for (i = 0, len = domEventCallbacks.length; i < len; i++) {\n      fn = domEventCallbacks[i];\n      result = fn.call(component, event, this);\n    }\n\n    if (componentMap = component.eventUpdateConfig[eventType]) {\n      for (_ in componentMap) {\n        comp = componentMap[_];\n        comp.render();\n      }\n\n      dc.clean();\n    }\n\n    if (event) {\n      if (!event.executeDefault && event.preventDefault) {\n        event.preventDefault();\n      }\n\n      if (!event.continuePropagation && event.stopPropagation) {\n        event.stopPropagation();\n      }\n    }\n  }\n\n  if (event && event.dcEventResult != null) {\n    return event.dcEventResult;\n  } else {\n    return result;\n  }\n}; // the event in addEventListenerMap do not execute node[eventName]\n// e.g. https://developer.mozilla.org/en/docs/Web/Events/compositionstart\n// [2] The event was fired in versions of Gecko before 9.0, but didn't have the DOM Level 3 attributes and methods.\n// so it's necessary to addEventListener\n\n\n_exports.addEventListenerMap = addEventListenerMap = {};\nref = 'compositionstart compositionupdate compositionend'.split(/\\s/); // todo: finish the full list\n\nfor (i = 0, len = ref.length; i < len; i++) {\n  eventName = ref[i];\n  addEventListenerMap['on' + eventName] = true;\n}\n\n_exports.domEventHandlerFromArray = function (callbackArray) {\n  return function (event) {\n    var fn, j, len1;\n\n    for (j = 0, len1 = callbackArray.length; j < len1; j++) {\n      fn = callbackArray[j];\n      fn && fn.call(this.component, event, this);\n    }\n  };\n};\n\n_exports.extendEventValue = extendEventValue = function extendEventValue(props, prop, value, before) {\n  var oldValue;\n  oldValue = props[prop];\n\n  if (!oldValue) {\n    oldValue = [];\n  } else if (!(oldValue instanceof Array)) {\n    oldValue = [oldValue];\n  }\n\n  if (!value) {\n    value = [];\n  } else if (!(value instanceof Array)) {\n    value = [value];\n  }\n\n  if (before) {\n    return props[prop] = value.concat(oldValue);\n  } else {\n    return props[prop] = oldValue.concat(value);\n  }\n};\n\n_exports.addHandlerToCallbackArray = function (handler, callbacks, before) {\n  var callback, index, j, len1;\n\n  if (typeof handler === 'function') {\n    handler = [handler];\n  }\n\n  if (before) {\n    callback = handler.pop();\n\n    while (callback) {\n      if (!callback) {\n        dc.error('addHandlerToCallbackArray: callback is undefined');\n      }\n\n      index = callbacks.indexOf(callback);\n\n      if (index <= 0) {\n        callbacks.unshift(callback);\n      }\n\n      callback = handler.pop();\n    }\n  } else {\n    for (j = 0, len1 = handler.length; j < len1; j++) {\n      callback = handler[j];\n\n      if (!callback) {\n        dc.error('addHandlerToCallbackArray: callback is undefined');\n      }\n\n      index = callbacks.indexOf(callback);\n\n      if (index <= 0) {\n        callbacks.push(callback);\n      }\n    }\n  }\n};\n\nvar _default = _exports;\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/property/events.coffee?");

/***/ }),

/***/ "./src/property/index.coffee":
/*!***********************************!*\
  !*** ./src/property/index.coffee ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _classFn = _interopRequireDefault(__webpack_require__(/*! ./classFn */ \"./src/property/classFn.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nvar _exports;\n\n//export default\nmodule.exports = _exports = {};\nObject.assign(_exports, __webpack_require__(/*! ./attrs */ \"./src/property/attrs.coffee\"), __webpack_require__(/*! ./classFn */ \"./src/property/classFn.coffee\"), __webpack_require__(/*! ./style */ \"./src/property/style.coffee\"), __webpack_require__(/*! ./css-arith */ \"./src/property/css-arith.coffee\"), __webpack_require__(/*! ./events */ \"./src/property/events.coffee\"), __webpack_require__(/*! ./delegate-event */ \"./src/property/delegate-event.coffee\"), {\n  classFn: _classFn.default\n});\nvar _default = _exports;\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/property/index.coffee?");

/***/ }),

/***/ "./src/property/style.coffee":
/*!***********************************!*\
  !*** ./src/property/style.coffee ***!
  \***********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _dcUtil = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar _exports, styleFrom;\n\n//export default\nmodule.exports = _exports = {};\n\n_exports.styleFrom = styleFrom = function styleFrom(value) {\n  var i, item, j, key, len, len1, result, v;\n\n  if (typeof value === 'string') {\n    result = {};\n    value = value.trim().split(/\\s*;\\s*/);\n\n    for (i = 0, len = value.length; i < len; i++) {\n      item = value[i];\n      item = item.trim();\n\n      if (!item) {\n        continue;\n      }\n\n      var _item$split = item.split(/\\s*:\\s*/);\n\n      var _item$split2 = _slicedToArray(_item$split, 2);\n\n      key = _item$split2[0];\n      v = _item$split2[1];\n      result[key] = v;\n    }\n\n    return result;\n  } else if (value instanceof Array) {\n    result = {};\n\n    for (j = 0, len1 = value.length; j < len1; j++) {\n      item = value[j];\n\n      if (typeof item === 'string') {\n        item = item.trim();\n\n        if (!item) {\n          continue;\n        }\n\n        var _item$split3 = item.split(/\\s*:\\s*/);\n\n        var _item$split4 = _slicedToArray(_item$split3, 2);\n\n        key = _item$split4[0];\n        value = _item$split4[1];\n      } else {\n        var _item = item;\n\n        var _item2 = _slicedToArray(_item, 2);\n\n        key = _item2[0];\n        value = _item2[1];\n      }\n\n      result[key] = value;\n    }\n\n    return result;\n  } else if (value && _typeof(value) !== 'object') {\n    return {};\n  } else {\n    return (0, _dcUtil.cloneObject)(value);\n  }\n};\n\nvar _default = _exports;\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/property/style.coffee?");

/***/ }),

/***/ "./src/tag.coffee":
/*!************************!*\
  !*** ./src/tag.coffee ***!
  \************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _dcUtil = __webpack_require__(/*! dc-util */ \"./packages/dc-util/index.js\");\n\nvar _isComponent = _interopRequireDefault(__webpack_require__(/*! ./component/isComponent */ \"./src/component/isComponent.coffee\"));\n\nvar _Tag = _interopRequireDefault(__webpack_require__(/*! ./component/Tag */ \"./src/component/Tag.coffee\"));\n\nvar _domUtil = __webpack_require__(/*! ./dom-util */ \"./src/dom-util.coffee\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nvar attrsChildren, _exports, i, inputTypes, isAttrs, j, len, len1, ref, tag, tagName, tagNames, _toTagChildren, type;\n\n//export default\nmodule.exports = _exports = {};\n\n_exports.isAttrs = isAttrs = function isAttrs(item) {\n  return _typeof(item) === 'object' && item !== null && !(0, _isComponent.default)(item) && !(item instanceof Array);\n};\n\nattrsChildren = function attrsChildren(args) {\n  var attrs;\n  attrs = args[0];\n\n  if (!args.length) {\n    return [{}, []];\n  } else if (attrs == null) {\n    return [{}, args.slice(1)];\n  } else if (attrs instanceof Array) {\n    return [{}, args];\n  } else if (typeof attrs === 'function') {\n    return [{}, args];\n  } else if (_typeof(attrs) === 'object') {\n    if ((0, _isComponent.default)(attrs)) {\n      return [{}, args];\n    } else {\n      return [attrs, args.slice(1)];\n    }\n  } else {\n    return [{}, args];\n  }\n};\n\n_toTagChildren = function toTagChildren(args) {\n  if (!(args instanceof Array)) {\n    return [args];\n  } else if (!args.length) {\n    return [];\n  } else if (args.length === 1) {\n    return _toTagChildren(args[0]);\n  } else {\n    return args;\n  }\n};\n\ntag = function tag(tagName) {\n  var attrs, children;\n\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  var _attrsChildren = attrsChildren(args);\n\n  var _attrsChildren2 = _slicedToArray(_attrsChildren, 2);\n\n  attrs = _attrsChildren2[0];\n  children = _attrsChildren2[1];\n  return new _Tag.default(tagName, attrs, _toTagChildren(children));\n};\n\ntagNames = \"a abbr acronym address area b base bdo big blockquote body br button caption cite code col colgroup dd del dfn div dl\" + \" dt em fieldset form h1 h2 h3 h4 h5 h6 head hr i img input ins kbd label legend li link map meta noscript object\" + \" ol optgroup option p param pre q samp script select small span strong style sub sup\" + \" table tbody td textarea tfoot th thead title tr tt ul var header footer section svg iframe\" + \" article aside bdi details dialog figcaption figure footer header main mark menuitem meter nav progress rp rt ruby summary time wbr\";\ntagNames = tagNames.split(' ');\n\nfor (i = 0, len = tagNames.length; i < len; i++) {\n  tagName = tagNames[i];\n\n  (function (tagName) {\n    return _exports[tagName] = function () {\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return tag.apply(void 0, [tagName].concat(args));\n    };\n  })(tagName);\n} // Because the name 'html' under dc has been used to instantiate Html component\n// So use tagHtml here, instead.\n// in client side, html is not necessary, because the dc component must be mounted somewhere\n\n\n_exports.tagHtml = function () {\n  for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n    args[_key3] = arguments[_key3];\n  }\n\n  return tag.apply(void 0, ['html'].concat(args));\n};\n\ninputTypes = 'text checkbox radio date email number'.split(' ');\n\n_exports.input = function (type, attrs, value) {\n  var component;\n\n  if (_typeof(type) === 'object') {\n    value = attrs;\n    attrs = type;\n    type = 'text';\n  }\n\n  attrs = Object.assign({\n    type: type\n  }, attrs);\n  component = tag('input', attrs);\n\n  if (value != null) {\n    component.prop((0, _domUtil.getBindProp)(component), value);\n\n    if (value.isDuplex) {\n      component.bind('onchange', function (event, node) {\n        return value.call(this, node.value);\n      }, 'before');\n    }\n  }\n\n  return component;\n};\n\nref = 'text checkbox radio date email tel number'.split(' ');\n\nfor (j = 0, len1 = ref.length; j < len1; j++) {\n  type = ref[j];\n\n  (function (type) {\n    return _exports[type] = function (value, attrs) {\n      var temp;\n\n      if (_typeof(value) === 'object') {\n        temp = attrs;\n        attrs = value;\n        value = temp;\n      }\n\n      attrs = attrs || {};\n      return input(type, attrs, value);\n    };\n  })(type);\n}\n\n_exports.textarea = function (attrs, value) {\n  var component;\n\n  if (isAttrs(attrs)) {\n    if (value != null) {\n      attrs = Object.assign({\n        value: value\n      }, attrs);\n      component = tag('textarea', attrs);\n\n      if (value.isDuplex) {\n        component.bind('onchange', function (event, node) {\n          return value.call(this, node.value);\n        }, 'before');\n      }\n    } else {\n      component = tag('textarea', attrs);\n    }\n  } else {\n    if (attrs != null) {\n      component = tag('textarea', {\n        value: attrs\n      });\n\n      if (attrs.isDuplex) {\n        component.bind('onchange', function (event, node) {\n          return attrs.call(this, node.value);\n        }, 'before');\n      }\n    } else {\n      component = tag('textarea'); // attrs is value\n    }\n  }\n\n  return component;\n};\n\nvar _default = _exports;\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/tag.coffee?");

/***/ })

/******/ });