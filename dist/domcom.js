/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "/assets/";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/index.coffee");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/_camelcase@4.1.0@camelcase/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/_camelcase@4.1.0@camelcase/index.js ***!
  \**********************************************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nfunction preserveCamelCase(str) {\n\tlet isLastCharLower = false;\n\tlet isLastCharUpper = false;\n\tlet isLastLastCharUpper = false;\n\n\tfor (let i = 0; i < str.length; i++) {\n\t\tconst c = str[i];\n\n\t\tif (isLastCharLower && /[a-zA-Z]/.test(c) && c.toUpperCase() === c) {\n\t\t\tstr = str.substr(0, i) + '-' + str.substr(i);\n\t\t\tisLastCharLower = false;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = true;\n\t\t\ti++;\n\t\t} else if (isLastCharUpper && isLastLastCharUpper && /[a-zA-Z]/.test(c) && c.toLowerCase() === c) {\n\t\t\tstr = str.substr(0, i - 1) + '-' + str.substr(i - 1);\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = false;\n\t\t\tisLastCharLower = true;\n\t\t} else {\n\t\t\tisLastCharLower = c.toLowerCase() === c;\n\t\t\tisLastLastCharUpper = isLastCharUpper;\n\t\t\tisLastCharUpper = c.toUpperCase() === c;\n\t\t}\n\t}\n\n\treturn str;\n}\n\nmodule.exports = function (str) {\n\tif (arguments.length > 1) {\n\t\tstr = Array.from(arguments)\n\t\t\t.map(x => x.trim())\n\t\t\t.filter(x => x.length)\n\t\t\t.join('-');\n\t} else {\n\t\tstr = str.trim();\n\t}\n\n\tif (str.length === 0) {\n\t\treturn '';\n\t}\n\n\tif (str.length === 1) {\n\t\treturn str.toLowerCase();\n\t}\n\n\tif (/^[a-z0-9]+$/.test(str)) {\n\t\treturn str;\n\t}\n\n\tconst hasUpperCase = str !== str.toLowerCase();\n\n\tif (hasUpperCase) {\n\t\tstr = preserveCamelCase(str);\n\t}\n\n\treturn str\n\t\t.replace(/^[_.\\- ]+/, '')\n\t\t.toLowerCase()\n\t\t.replace(/[_.\\- ]+(\\w|$)/g, (m, p1) => p1.toUpperCase());\n};\n\n\n//# sourceURL=webpack:///./node_modules/_camelcase@4.1.0@camelcase/index.js?");

/***/ }),

/***/ "./src/Component.coffee":
/*!******************************!*\
  !*** ./src/Component.coffee ***!
  \******************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _Emitter2 = _interopRequireDefault(__webpack_require__(/*! ./Emitter */ \"./src/Emitter.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nvar Component,\n    isArray,\n    isMap,\n    isObject,\n    newDcid,\n    normalizeDomElement,\n    updateKey,\n    watchDataField,\n    watchField,\n    hasProp = {}.hasOwnProperty;\n\nvar _require = __webpack_require__(/*! dc-util */ \"./src/dc-util.coffee\");\n\nnewDcid = _require.newDcid;\nisArray = _require.isArray;\nisObject = _require.isObject;\nnormalizeDomElement = _require.normalizeDomElement;\nwatchField = _require.watchField;\nwatchDataField = _require.watchDataField;\nisMap = _require.isMap;\nupdateKey = 1;\n/*\n  部件基类\n  @params config: the config object for the component, it can have the fileds below\n    data: the real data of the component or a function to generate the data\n    view: the view object or a function to generate the view\n    any other fields that do not conflict with component itself\n*/\n\nvar _default = module.exports = Component =\n/*#__PURE__*/\nfunction (_Emitter) {\n  _inherits(Component, _Emitter);\n\n  function Component(config) {\n    var _this;\n\n    _classCallCheck(this, Component);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Component).call(this));\n\n    _this.init();\n\n    _this.checkConfig(config);\n\n    _this.config = config;\n    Object.assign(_assertThisInitialized(_assertThisInitialized(_this)), config);\n\n    _this.watch();\n\n    return _possibleConstructorReturn(_this);\n  }\n\n  _createClass(Component, [{\n    key: \"init\",\n    value: function init() {\n      this.dcid = newDcid();\n      this.base = null;\n      this.reactElement = null;\n      this.node = null;\n      this.mounted = false;\n    }\n  }, {\n    key: \"getReactElement\",\n    value: function getReactElement(key) {\n      var props;\n\n      if (this.reactElement) {\n        return this.reactElement;\n      }\n\n      if (key != null) {\n        props = {\n          component: this,\n          key: key\n        };\n      } else {\n        props = {\n          component: this\n        };\n      }\n\n      props.key = props.key || this.dcid;\n      this.reactElement = dc.React.createElement(dc.ReactProxy, props);\n      return this.reactElement;\n    }\n  }, {\n    key: \"checkConfig\",\n    value: function checkConfig(config) {\n      var illegals, key, value;\n      illegals = [];\n\n      for (key in config) {\n        if (!hasProp.call(config, key)) continue;\n        value = config[key];\n\n        if (this[key] !== void 0) {\n          illegals.push(key);\n        }\n      }\n\n      if (illegals.length) {\n        dc.error(\"illegal key in config: \".concat(illegals.join(', '), \", they are used by dc.Component itself!\"));\n      }\n    }\n  }, {\n    key: \"watch\",\n    value: function watch() {\n      var components, config, data, key, ref;\n\n      if (config = this.config) {\n        for (key in config) {\n          if (!hasProp.call(config, key)) continue;\n          watchField(this, key, this);\n        }\n      }\n\n      if ((data = this.getData(dc.store)) && isMap(data)) {\n        components = data.watchingComponents;\n\n        if (!components) {\n          data.watchingComponents = [this];\n        } else {\n          if (components.indexOf(this) === -1) {\n            components.push(this);\n          }\n        }\n\n        if (data && isMap(data)) {\n          ref = config.data;\n\n          for (key in ref) {\n            if (!hasProp.call(ref, key)) continue;\n            watchDataField(config.data, key, this);\n          }\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"stopWatch\",\n    value: function stopWatch() {\n      var components, config, data, index, key, v;\n\n      if (config = this.config) {\n        for (key in config) {\n          if (!hasProp.call(config, key)) continue;\n          v = this[key];\n          delete this[key];\n          this[key] = v;\n        }\n\n        if ((data = config.data) && isMap(data)) {\n          components = data.watchingComponents;\n          index = components.indexOf(this);\n\n          if (index >= 0) {\n            components.splice(index, 1);\n            delete data.watchingComponents;\n\n            if (!components.length) {\n              for (key in data) {\n                if (!hasProp.call(data, key)) continue;\n                v = data[key];\n                delete data[key];\n                data[key] = v;\n              }\n            }\n          }\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"copy\",\n    value: function copy() {\n      var comp;\n      comp = new Component({});\n      Object.assign(comp, this);\n      comp.init();\n      comp.watch();\n      return comp;\n    }\n  }, {\n    key: \"extend\",\n    value: function extend(config) {\n      var comp;\n      comp = new Component({});\n      component.base = this;\n      comp.checkConfig(config);\n      Object.assign(comp, this, config);\n      comp.init();\n      comp.config = Object.assign({}, this.config, config);\n      return comp;\n    }\n  }, {\n    key: \"mount\",\n    value: function mount(mountNode) {\n      var reactElement;\n\n      this._prepareMount(mountNode);\n\n      dc.mountMap[this.dcid] = this;\n      reactElement = this.getReactElement();\n      dc.ReactDom.render(reactElement, this.parentNode);\n      this.emit('mounted');\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      console.log(' component.update:', this);\n\n      if (this.mounted) {\n        // any object to trigger the update\n        this.proxy.setState({});\n      }\n    }\n  }, {\n    key: \"_prepareMount\",\n    value: function _prepareMount(mountNode) {\n      var parentNode;\n      parentNode = normalizeDomElement(mountNode) || document.body;\n\n      if (parentNode.childNodes.length) {\n        dc.error('should not mount to node which is not empty:', mountNode);\n      }\n\n      this.parentNode = parentNode;\n    }\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      if (typeof this.data === 'function') {\n        return this.data.call(this, dc.store);\n      } else {\n        return this.data;\n      }\n    }\n  }, {\n    key: \"getView\",\n    value: function getView() {\n      var data, view;\n      data = this.getData();\n\n      if (this.view) {\n        if (typeof this.view === 'function') {\n          view = this.view.call(this, data);\n        } else {\n          view = this.view;\n        }\n\n        return view;\n      }\n    }\n  }, {\n    key: \"unmount\",\n    value: function unmount() {\n      var node, parentNode;\n      this.emit('unmounting');\n      parentNode = this.parentNode;\n\n      if (parentNode.childNodes.length) {\n        node = parentNode.childNodes[0];\n        parentNode.removeChild(node);\n      } //tell React do not warn about this\n\n\n      parentNode._reactRootContainer = void 0;\n      this.proxy.component = null;\n      this.proxy = null;\n      delete dc.mountMap[this.dcid];\n      this.unmounted = false;\n    }\n  }]);\n\n  return Component;\n}(_Emitter2.default);\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/Component.coffee?");

/***/ }),

/***/ "./src/Emitter.coffee":
/*!****************************!*\
  !*** ./src/Emitter.coffee ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\n/*\nModel, View, Component等很多类的基类\n管理注册／注销回调函数(on/once/off/offall)和事件发布(emit)\n*/\nvar Emitter;\n\nvar _default = module.exports = Emitter =\n/*#__PURE__*/\nfunction () {\n  function Emitter() {\n    _classCallCheck(this, Emitter);\n  }\n  /*注册事件\n    comp.on({name:callbacks...})\n    comp.on(name, callback, before = false)\n    comp.on(name, callbacks, before = false)\n  */\n\n\n  _createClass(Emitter, [{\n    key: \"on\",\n    value: function on(event, callback) {\n      var callbacks, eventName, i, len, listeners, ref;\n\n      if (!arguments.length) {\n        dc.error('missing arguments for Component.on(event, callback)');\n      }\n\n      if (arguments.length === 1) {\n        if (!event || _typeof(event) !== 'object') {\n          dc.error('wrong arguments for Component.on(event, callback)');\n        } else {\n          for (eventName in event) {\n            callback = event[eventName];\n            this.on(eventName, callback);\n          }\n        }\n      } else {\n        if (!callback) {\n          dc.error('Component.on: callback is undefined for event: ' + event);\n        }\n\n        if (!(listeners = this.listeners)) {\n          this.listeners = listeners = {};\n        }\n\n        ref = event.split(/\\s*,\\s*|\\s+/);\n\n        for (i = 0, len = ref.length; i < len; i++) {\n          event = ref[i];\n\n          if (callbacks = listeners[event]) {\n            if (callbacks.indexOf(callback) < 0) {\n              callbacks.push(callback);\n            }\n          } else {\n            listeners[event] = [callback];\n          }\n        }\n      }\n\n      return this;\n    }\n    /*注册事件\n     * comp.off(name, callback)\n     * 注销部件上指定name的指定回调函数\n      * comp.off(name)\n     * 注销部件上指定name的所有回调函数\n      * comp.off() \n    #注销部件上的所有事件的所有回调函数\n      */\n\n  }, {\n    key: \"off\",\n    value: function off(event, callback) {\n      var callbacks, i, index, j, len, len1, listeners, ref, ref1;\n\n      if (!arguments.length) {\n        this.listeners = {};\n      } else if (arguments.length === 1) {\n        listeners = this.listeners;\n        ref = event.split(/\\s*,\\s*|\\s+/);\n\n        for (i = 0, len = ref.length; i < len; i++) {\n          event = ref[i];\n          listeners[event] = null;\n        }\n      } else {\n        listeners = this.listeners;\n        ref1 = event.split(/\\s*,\\s*|\\s+/);\n\n        for (j = 0, len1 = ref1.length; j < len1; j++) {\n          event = ref1[j];\n          callbacks = listeners[event];\n\n          if (callbacks && (index = callbacks.indexOf(callback)) >= 0) {\n            callbacks.splice(index, 1);\n\n            if (!callbacks.length) {\n              listeners[event] = null;\n            }\n          }\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"once\",\n    value: function once(event, callback) {\n      var _onceCallback;\n\n      if (!callback) {\n        dc.error('Component.once: callback is undefined for event: ' + event);\n      }\n\n      _onceCallback = function onceCallback() {\n        this.off(event, _onceCallback);\n\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        return callback.apply(this, args);\n      };\n\n      return this.on(event, _onceCallback);\n    }\n  }, {\n    key: \"emit\",\n    value: function emit(event) {\n      var callback, callbacks, i, len, method;\n\n      if (!this.destroyed) {\n        for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          args[_key2 - 1] = arguments[_key2];\n        }\n\n        if (this.listeners && (callbacks = this.listeners[event])) {\n          // need to be copied, because onceCallback will be removed from this.listeners[event]\n          callbacks = callbacks.slice();\n\n          for (i = 0, len = callbacks.length; i < len; i++) {\n            callback = callbacks[i];\n            callback.apply(this, args);\n          }\n        } else {\n          if (method = this['on' + event]) {\n            method.apply(this, args);\n          }\n        }\n      }\n\n      return this;\n    }\n  }]);\n\n  return Emitter;\n}();\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/Emitter.coffee?");

/***/ }),

/***/ "./src/dc-directive.coffee":
/*!*********************************!*\
  !*** ./src/dc-directive.coffee ***!
  \*********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _dcUtil = __webpack_require__(/*! ./dc-util */ \"./src/dc-util.coffee\");\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar _exports, modelProps;\n\nvar _default = _exports = module.exports = {};\n\nexports.default = _default;\nmodelProps = {\n  'checkbox': 'checked'\n};\n\n_exports.$model = function (item, options) {\n  var children, comp, event, field, prop, props, tag;\n\n  var _item = _slicedToArray(item, 3);\n\n  tag = _item[0];\n  props = _item[1];\n  children = _item[2];\n  comp = this;\n\n  if (typeof options === 'string') {\n    field = options;\n  } else if (options) {\n    field = options.field;\n    event = options.event || 'onChange';\n    prop = options.prop;\n  }\n\n  props = Object.assign({}, props);\n  prop = prop || modelProps[props.type] || 'value';\n  props[prop] = comp[field];\n\n  props[event || 'onChange'] = function (event) {\n    return comp[field] = event.target[prop];\n  };\n\n  return [tag, props, children];\n}; //$output just reverse node.value to field, but NOT bind field to props.value\n\n\n_exports.$output = function (item, options) {\n  var children, comp, event, field, prop, props, tag;\n\n  var _item2 = _slicedToArray(item, 3);\n\n  tag = _item2[0];\n  props = _item2[1];\n  children = _item2[2];\n  comp = this;\n\n  if (typeof options === 'string') {\n    field = options;\n  } else if (options) {\n    field = options.field;\n    event = options.event || 'onChange';\n    prop = options.prop;\n  }\n\n  props = Object.assign({}, props);\n\n  props[event || 'onChange'] = function (event) {\n    return comp[field] = event.target[prop];\n  };\n\n  return [tag, props, children];\n};\n\n_exports.$options = function (item, options) {\n  var children, props, tag;\n\n  var _item3 = _slicedToArray(item, 3);\n\n  tag = _item3[0];\n  props = _item3[1];\n  children = _item3[2];\n\n  if ((0, _dcUtil.isArray)(options)) {\n    children = options.map(function (child) {\n      return ['option', {}, [child]];\n    });\n  }\n\n  return [tag, props, children];\n};\n\n_exports.$show = function (item, options) {\n  var children, props, style, tag, value;\n\n  var _item4 = _slicedToArray(item, 3);\n\n  tag = _item4[0];\n  props = _item4[1];\n  children = _item4[2];\n\n  if (typeof options === 'string' || typeof options === 'number') {\n    value = this[options];\n  } else {\n    value = options;\n  }\n\n  style = props.style || (props.style = {});\n\n  if (value) {\n    style.display = 'block';\n  } else {\n    style.display = 'none';\n  }\n\n  return [tag, props, children];\n};\n\n//# sourceURL=webpack:///./src/dc-directive.coffee?");

/***/ }),

/***/ "./src/dc-error.coffee":
/*!*****************************!*\
  !*** ./src/dc-error.coffee ***!
  \*****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === \"function\" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== \"function\") { throw new TypeError(\"Super expression must either be null or a function\"); } if (typeof _cache !== \"undefined\") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction isNativeReflectConstruct() { if (typeof Reflect === \"undefined\" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === \"function\") return true; try { Date.prototype.toString.call(Reflect.construct(Date, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _construct(Parent, args, Class) { if (isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf(\"[native code]\") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nvar DomcomError, _exports, slice, stackReg, stackReg2, stacktraceMessage;\n\nslice = [].slice;\nstackReg = /at\\s+(.*)\\s+\\((.*):(\\d*):(\\d*)\\)/gi;\nstackReg2 = /at\\s+()(.*):(\\d*):(\\d*)/gi; //export default\n\nmodule.exports = _exports = {};\n\nstacktraceMessage = function stacktraceMessage(message) {\n  var stackIndex = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  var error, file, itemInfo, line, method, pos, stackItem, stacklist, stacklistLength;\n\n  if (message) {\n    if (!dc.prodution) {\n      console.log(message);\n    }\n\n    message += ':\\n';\n  } else {\n    message = \"\";\n  }\n\n  error = new Error();\n\n  if (!dc.prodution) {\n    console.log(error);\n  }\n\n  stacklist = error.stack.split('\\n').slice(3);\n  stackIndex = 1;\n  stacklistLength = stacklist.length;\n\n  while (stackIndex < stacklistLength) {\n    stackItem = stacklist[stackIndex];\n    itemInfo = stackReg.exec(stackItem) || stackReg2.exec(stackItem);\n\n    if (itemInfo && itemInfo.length === 5) {\n      method = itemInfo[1];\n      file = itemInfo[2];\n      line = itemInfo[3];\n      pos = itemInfo[4];\n      message += file + ':' + line + ':' + pos + ':' + method + '\\n';\n    }\n\n    stackIndex++;\n  }\n\n  return message;\n};\n\n_exports.DomcomError = DomcomError =\n/*#__PURE__*/\nfunction (_Error) {\n  _inherits(DomcomError, _Error);\n\n  function DomcomError(message1, component1) {\n    var _this;\n\n    _classCallCheck(this, DomcomError);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(DomcomError).call(this));\n    _this.message = message1;\n    _this.component = component1;\n    return _this;\n  }\n\n  _createClass(DomcomError, [{\n    key: \"toString\",\n    value: function toString() {\n      if (this.component) {\n        return this.component.toString() + '\\n' + this.message;\n      } else {\n        return this.message;\n      }\n    }\n  }]);\n\n  return DomcomError;\n}(_wrapNativeSuper(Error));\n\n_exports.error = function (message, component) {\n  message = stacktraceMessage(message, 2);\n  throw new DomcomError(message, component);\n};\n\nvar _default = _exports;\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/dc-error.coffee?");

/***/ }),

/***/ "./src/dc-util.coffee":
/*!****************************!*\
  !*** ./src/dc-util.coffee ***!
  \****************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance\"); }\n\nfunction _iterableToArray(iter) { if (Symbol.iterator in Object(iter) || Object.prototype.toString.call(iter) === \"[object Arguments]\") return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = new Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nvar camelCase, camelCaseProps, classname, dcid, _exports, inputTypes, isArray, isMap, isObject, isReactClass, j, len, normalizeArrayViewItem, normalizeItem, normalizeReactProps, parseTagString, ref, styleFrom, type;\n\ncamelCase = __webpack_require__(/*! camelcase */ \"./node_modules/_camelcase@4.1.0@camelcase/index.js\");\n\nvar _default = _exports = module.exports = {};\n\nexports.default = _default;\n\n_exports.normalizeItem = normalizeItem = function normalizeItem(item, index) {\n  if (typeof item === 'string') {\n    return item;\n  } else if (item instanceof dc.Component) {\n    return item.getReactElement(index);\n  } else if (isArray(item)) {\n    return normalizeArrayViewItem(item);\n  } else if (item != null) {\n    return '' + item;\n  } else {\n    return null;\n  }\n};\n\nnormalizeArrayViewItem = function normalizeArrayViewItem(item) {\n  var _, children, classes, css, i, id, inputType, it, props, tag, x;\n\n  i = 0;\n  it = item[i];\n\n  if (it instanceof dc.Component || isArray(it)) {\n    tag = 'div';\n    props = {};\n    children = item.map(function (child, index) {\n      return normalizeItem(child, index);\n    });\n    return [tag, props, children];\n  } else if (typeof it === 'string') {\n    var _parseTagString = parseTagString(item[i]);\n\n    var _parseTagString2 = _slicedToArray(_parseTagString, 5);\n\n    tag = _parseTagString2[0];\n    classes = _parseTagString2[1];\n    id = _parseTagString2[2];\n    css = _parseTagString2[3];\n    inputType = _parseTagString2[4];\n    classes = classname(classes);\n    css = styleFrom(css);\n    i++;\n  } else if (isReactClass(it)) {\n    tag = it;\n    i++;\n    it = item[i];\n\n    if (typeof it === 'string' && it) {\n      if (it.match(/^\\.|^#/)) {\n        var _parseTagString3 = parseTagString(item[i]);\n\n        var _parseTagString4 = _slicedToArray(_parseTagString3, 5);\n\n        _ = _parseTagString4[0];\n        classes = _parseTagString4[1];\n        id = _parseTagString4[2];\n        css = _parseTagString4[3];\n        inputType = _parseTagString4[4];\n        classes = classname(classes);\n        css = styleFrom(css);\n        i++;\n        it = item[i];\n      }\n    }\n  } else if (typeof it === 'function') {\n    x = it.apply(void 0, _toConsumableArray(item.slice(1)));\n    return normalizeItem(x);\n  } // props and children\n\n\n  props = null;\n  it = item[i];\n\n  while (isMap(it)) {\n    props = Object.assign({\n      id: id\n    }, it);\n    tag = tag || it.tag || 'div';\n    delete props.tag;\n    classes = classname(classes, it.classes, it.className);\n    delete props.classes;\n    props.className = classes;\n    css = styleFrom(css, it.css, it.style);\n    delete props.css;\n    props.style = css;\n    i++;\n    it = item[i];\n  }\n\n  if (!props) {\n    props = {\n      className: classes,\n      id: id,\n      style: styleFrom(css)\n    };\n  }\n\n  if (inputType) {\n    props.type = inputType;\n  }\n\n  children = item.slice(i).map(function (child, index) {\n    return normalizeItem(child, index);\n  });\n  props = normalizeReactProps(props, typeof tag === 'string');\n  return [tag || 'div', props, children];\n};\n\nnormalizeReactProps = function normalizeReactProps(props) {\n  var camel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  var classMap, classes, key, value;\n\n  if (props.dontCamel) {\n    camel = false;\n    delete props.dontCamel;\n  }\n\n  for (key in props) {\n    value = props[key];\n\n    if (camel) {\n      delete props[key];\n      key = camelCase(key);\n    }\n\n    if (value === void 0) {\n      delete props[key];\n    } else if (key === 'className') {\n      classMap = classname(value);\n\n      if (classes = Object.keys(classMap).filter(function (key) {\n        return classMap[key];\n      }).join(' ')) {\n        props.className = classes;\n      } else {\n        delete props.className;\n      }\n    } else if (key === 'style') {\n      if (Object.keys(value).length) {\n        props.style = camelCaseProps(value);\n      } else {\n        delete props.style;\n      }\n    } else if (camel) {\n      props[key] = value;\n    }\n  }\n\n  return props;\n};\n\ncamelCaseProps = function camelCaseProps(props) {\n  var key, result, value;\n  result = {};\n\n  for (key in props) {\n    value = props[key];\n    key = camelCase(key);\n    result[key] = value;\n  }\n\n  return result;\n};\n\ninputTypes = {};\nref = 'text checkbox radio date email tel number password'.split(' ');\n\nfor (j = 0, len = ref.length; j < len; j++) {\n  type = ref[j];\n  inputTypes[type] = 1;\n} // tag.class#id##css\n\n\nparseTagString = function parseTagString(str) {\n  var classes, css, id, inputType, list, tag;\n  str = str.trim();\n  list = str.split('##');\n\n  if (list.length === 2) {\n    css = list[1].trim();\n    str = list[0].trim();\n  }\n\n  list = str.split('#');\n\n  if (list.length === 2) {\n    id = list[1].trim();\n    str = list[0].trim();\n  }\n\n  list = str.split('.');\n\n  if (list.length > 1) {\n    tag = list[0];\n    classes = classname(list.slice(1));\n  } else {\n    tag = str;\n    classes = [];\n  }\n\n  if (inputTypes[tag]) {\n    inputType = tag;\n    tag = 'input';\n  }\n\n  return [tag || 'div', classes, id, css, inputType];\n};\n\nstyleFrom = function styleFrom() {\n  var def, defs, item, k, key, l, len1, len2, result, value;\n  result = {};\n\n  for (var _len = arguments.length, items = new Array(_len), _key = 0; _key < _len; _key++) {\n    items[_key] = arguments[_key];\n  }\n\n  for (k = 0, len1 = items.length; k < len1; k++) {\n    item = items[k];\n\n    if (typeof item === 'string') {\n      item = item.trim();\n\n      if (!item) {\n        continue;\n      }\n\n      defs = item.split(/\\s*;\\s*/);\n\n      for (l = 0, len2 = defs.length; l < len2; l++) {\n        def = defs[l];\n\n        if (!def) {\n          continue;\n        }\n\n        var _def$split = def.split(/\\s*:\\s*/);\n\n        var _def$split2 = _slicedToArray(_def$split, 2);\n\n        key = _def$split2[0];\n        value = _def$split2[1];\n\n        if (!key || !value) {\n          dc.error('format error in css rules: empty key');\n        } else if (!value) {\n          dc.error('format error in css rules: empty value');\n        }\n\n        key = camelCase(key);\n        result[key] = value;\n      }\n    } else if (isMap(item)) {\n      Object.assign(result, item);\n    }\n  }\n\n  return result;\n};\n\nclassname = function classname() {\n  var classMap, item, k, l, len1, len2, len3, m, name, names;\n  classMap = {};\n\n  for (var _len2 = arguments.length, items = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n    items[_key2] = arguments[_key2];\n  }\n\n  for (k = 0, len1 = items.length; k < len1; k++) {\n    item = items[k];\n\n    if (!item) {\n      continue;\n    } else if (typeof item === 'string') {\n      names = item.trim().split(/(?:\\s*,\\s*)|s+/);\n\n      for (l = 0, len2 = names.length; l < len2; l++) {\n        name = names[l];\n        classMap[name] = 1;\n      }\n    } else if (isArray(item)) {\n      for (m = 0, len3 = item.length; m < len3; m++) {\n        name = item[m];\n        classMap[name] = 1;\n      }\n    } else if (isObject(item)) {\n      Object.assign(classMap, item);\n    }\n  }\n\n  return classMap;\n};\n\nisReactClass = function isReactClass(item) {\n  // investigated on both CreateClass and ES6 extends react.Component\n  return item && item.prototype && item.prototype.isReactComponent;\n};\n\n_exports.watchField = function (data, prop, comp) {\n  var closure;\n\n  closure = function closure() {\n    var value;\n    value = data[prop];\n    Object.defineProperty(data, prop, {\n      get: function get() {\n        return value;\n      },\n      set: function set(v) {\n        value = v;\n        return comp.update();\n      }\n    });\n  };\n\n  closure();\n};\n\n_exports.watchDataField = function (data, prop, comp) {\n  (function () {\n    var value;\n    value = data[prop];\n    Object.defineProperty(data, prop, {\n      get: function get() {\n        return value;\n      },\n      set: function set(v) {\n        var k, len1, ref1;\n\n        if (v !== value) {\n          value = v;\n          ref1 = data.watchingComponents;\n\n          for (k = 0, len1 = ref1.length; k < len1; k++) {\n            comp = ref1[k];\n            comp.update();\n          }\n        }\n\n        return v;\n      }\n    });\n  })();\n};\n\n_exports.normalizeDomElement = function (domElement) {\n  if (typeof domElement === 'string') {\n    domElement = document.querySelector(domElement);\n  }\n\n  return domElement;\n};\n\n_exports.isArray = isArray = isArray = function isArray(item) {\n  return Object.prototype.toString.call(item) === '[object Array]';\n};\n\n_exports.isObject = isObject = function isObject(item) {\n  return _typeof(item) === 'object' && item !== null;\n};\n\n_exports.isMap = isMap = function isMap(item) {\n  return _typeof(item) === 'object' && item !== null && item.constructor === Object;\n};\n\ndcid = 0;\n\n_exports.newDcid = function () {\n  return dcid++;\n};\n\n//# sourceURL=webpack:///./src/dc-util.coffee?");

/***/ }),

/***/ "./src/index.coffee":
/*!**************************!*\
  !*** ./src/index.coffee ***!
  \**************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _Emitter = _interopRequireDefault(__webpack_require__(/*! ./Emitter */ \"./src/Emitter.coffee\"));\n\nvar _Component = _interopRequireDefault(__webpack_require__(/*! ./Component */ \"./src/Component.coffee\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/*\n * a utility to do almost everything\n * generate Component instance\n * as the dc framework namespace\n * hold convinent getter, setter and method, etc...\n * @params template: the template for the component\n * @params config: the config object for the component, it can have the fileds below\n    model can be the real value of data or a function to generate the model data\n    data: the data of the component\n    view: the view object or a function to generate the view\n */\nvar dc;\n\ndc = function dc(config) {\n  var comp;\n  comp = new _Component.default(config);\n  return comp;\n};\n\ndc.on = _Emitter.default.prototype.on;\ndc.off = _Emitter.default.prototype.off;\ndc.emit = _Emitter.default.prototype.emit;\ndc.focusNodeMap = {};\ndc.on('updated', function () {\n  if (dc.focusNode) {\n    dc.focusNode.focus();\n  }\n});\ndc.dcid = 0;\ndc.mountMap = {};\ndc.keepReactElementMap = {};\n\ndc.update = function () {\n  var comp, key, ref;\n  ref = dc.mountMap;\n\n  for (key in ref) {\n    comp = ref[key];\n    comp.update();\n  }\n};\n\nif (typeof window !== 'undefined') {\n  window.dc = dc;\n}\n\ndc.Component = __webpack_require__(/*! ./Component */ \"./src/Component.coffee\");\nObject.assign(dc, __webpack_require__(/*! ./dc-error */ \"./src/dc-error.coffee\"), __webpack_require__(/*! dc-util */ \"./src/dc-util.coffee\"));\ndc.directives = {};\nObject.assign(dc.directives, __webpack_require__(/*! ./dc-directive */ \"./src/dc-directive.coffee\"));\ndc.addReactProxy = __webpack_require__(/*! ./react-proxy */ \"./src/react-proxy.coffee\");\nwindow.dc = dc;\n\nvar _default = module.exports = dc;\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/index.coffee?");

/***/ }),

/***/ "./src/react-proxy.coffee":
/*!********************************!*\
  !*** ./src/react-proxy.coffee ***!
  \********************************/
/*! no static exports found */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
eval("\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance\"); }\n\nfunction _iterableToArrayLimit(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nvar addReactProxy,\n    globalKey,\n    normalizeItem,\n    boundMethodCheck = function boundMethodCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new Error('Bound instance method accessed before binding');\n  }\n};\n\nvar _require = __webpack_require__(/*! dc-util */ \"./src/dc-util.coffee\");\n\nnormalizeItem = _require.normalizeItem;\nglobalKey = 0;\n/*\naddReactProxy should be attached to dc and called like below:\n  dc.addReactProxy(React, ReactDom, ReactComponent)\n*/\n\nvar _default = module.exports = addReactProxy = function addReactProxy(React, ReactDom, ReactComponent) {\n  var ReactProxy, dc;\n  dc = this;\n  dc.React = React;\n  dc.ReactDom = ReactDom;\n  return dc.ReactProxy = ReactProxy =\n  /*#__PURE__*/\n  function (_ReactComponent) {\n    _inherits(ReactProxy, _ReactComponent);\n\n    function ReactProxy(props) {\n      var _this;\n\n      _classCallCheck(this, ReactProxy);\n\n      var component;\n      _this = _possibleConstructorReturn(this, _getPrototypeOf(ReactProxy).call(this, props));\n      _this.renderNormalized = _this.renderNormalized.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n      _this.renderItem = _this.renderItem.bind(_assertThisInitialized(_assertThisInitialized(_this)));\n      component = props.component;\n      _this.component = component;\n      component.proxy = _assertThisInitialized(_assertThisInitialized(_this));\n      return _possibleConstructorReturn(_this);\n    }\n\n    _createClass(ReactProxy, [{\n      key: \"componentWillMount\",\n      value: function componentWillMount() {\n        console.log(' componentWillMount:', this.component);\n        this.component.emit('mounting');\n      }\n    }, {\n      key: \"componentDidMount\",\n      value: function componentDidMount() {\n        console.log(' componentDidMount:', this.component);\n        this.component.node = ReactDom.findDOMNode(this);\n        this.component.watch();\n\n        if (this.component.mounted) {\n          dc.error('component should be mounted under only one place');\n        }\n\n        this.component.emit('mounted');\n        dc.emit('mounted');\n        this.component.mounted = true;\n      }\n    }, {\n      key: \"componentWillUnmount\",\n      value: function componentWillUnmount() {\n        dc.emit('unmounting');\n        this.component.emit('unmounting');\n        this.component.mounted = false;\n        this.component.node = null;\n      }\n    }, {\n      key: \"componentDidCatch\",\n      value: function componentDidCatch(error) {\n        return dc.error(error);\n      }\n    }, {\n      key: \"componentWillUpdate\",\n      value: function componentWillUpdate(prevProps, prevState) {\n        dc.emit('updating');\n        this.component.emit('updating');\n      }\n    }, {\n      key: \"componentDidUpdate\",\n      value: function componentDidUpdate(prevProps, prevState) {\n        this.component.node = ReactDom.findDOMNode(this);\n        this.component.emit('updated');\n        dc.emit('updated');\n      }\n    }, {\n      key: \"renderNormalized\",\n      value: function renderNormalized(item, index) {\n        var _this2 = this;\n\n        var children, directive, focusid, keepid, key, onBlur, onFocus, props, reactElement, ref, tag, value;\n        boundMethodCheck(this, ReactProxy);\n        console.log(' renderNormalized: item, index:', item, index);\n\n        if (item == null) {\n          return null;\n        } else if (typeof item === 'string') {\n          return item;\n        } else if (dc.React.isValidElement(item)) {\n          // item.key = item.key || index\n          return item;\n        } else {\n          props = Object.assign({}, item[1]);\n\n          for (key in props) {\n            value = props[key];\n\n            if (key[0] === '$') {\n              directive = dc.directives[key];\n              delete item[1][key];\n              item = directive.call(this.component, item, value);\n            }\n          }\n\n          var _item = item;\n\n          var _item2 = _slicedToArray(_item, 3);\n\n          tag = _item2[0];\n          props = _item2[1];\n          children = _item2[2];\n\n          if (tag === 'input' || tag === 'textarea') {\n            if (children.length > 1) {\n              dc.error(\"\".concat(tag, \" element should not have multiple children\"));\n            } else if (children.length === 1) {\n              if (typeof children[0] !== 'string') {\n                dc.error('the child of #{tag} is used as model field, it should be a string');\n              }\n\n              item = dc.directives.$model.call(this.component, item, children[0]);\n              props = item[1];\n              children = [];\n            }\n          }\n\n          if (!props.key) {\n            props.key = index;\n          }\n\n          if ((focusid = props.focusid) != null) {\n            ref = props.ref;\n\n            props.ref = function (el) {\n              ref && ref(el);\n\n              if (focusid === dc.focusid) {\n                dc.focusNode = el;\n              }\n            };\n\n            onFocus = props.onFocus;\n\n            props.onFocus = function (event) {\n              onFocus && onFocus(event);\n              dc.focusid = focusid;\n            };\n\n            onBlur = props.onBlur;\n\n            props.onBlur = function (event) {\n              onBlur && onBlur(event);\n              dc.focusid = null;\n            };\n          }\n\n          children = children.map(function (child, index) {\n            return _this2.renderNormalized(child, index);\n          });\n\n          if (!children.length) {\n            children = null;\n          } else if (children.length === 1) {\n            if (props.useSingleChildren) {\n              delete props.useSingleChildren;\n              children = children[0];\n            }\n          }\n\n          if (keepid = props.keepid) {\n            delete props.keepid;\n\n            if (reactElement = dc.keepReactElementMap[keepid]) {\n              return reactElement;\n            } else {\n              reactElement = React.createElement(tag, props, children);\n              dc.keepReactElementMap[keepid] = reactElement;\n              return reactElement;\n            }\n          } else {\n            return React.createElement(tag, props, children);\n          }\n        }\n      }\n    }, {\n      key: \"renderItem\",\n      value: function renderItem(item) {\n        boundMethodCheck(this, ReactProxy);\n        item = normalizeItem(item);\n        return this.renderNormalized(item);\n      }\n    }, {\n      key: \"render\",\n      value: function render() {\n        var component, reactElement, view;\n        component = this.component;\n\n        if (component.dcid === 1) {\n          debugger;\n        }\n\n        view = component.getView();\n        console.log(' react-proxy.render view:', view);\n        reactElement = this.renderItem(view);\n        console.log(' react-proxy.render reactElement:', reactElement);\n        return reactElement;\n      }\n    }]);\n\n    return ReactProxy;\n  }(ReactComponent);\n};\n\nexports.default = _default;\n\n//# sourceURL=webpack:///./src/react-proxy.coffee?");

/***/ })

/******/ });